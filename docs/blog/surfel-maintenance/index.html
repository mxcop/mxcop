<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><title>MΛX - Surfel Maintenance for Global Illumination</title><meta content="© 2020-2024 Max <mxcop>, All rights reserved" name=copyright><meta content="A comprehensive explanation of my implementation of Surfel probe maintenance." name=description><meta content=https://m4xc.dev/img/blog/surfel-maintenance/surfel-splash.png itemprop=image><meta content=https://m4xc.dev/ property=og:url><meta content=website property=og:type><meta content=https://m4xc.dev/img/blog/surfel-maintenance/surfel-splash.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=https://m4xc.dev/img/blog/surfel-maintenance/surfel-splash.png name=twitter:image><link href=https://m4xc.dev/general.css rel=stylesheet><meta content="Max <mxcop>" name=author><meta content=graphics, surfels name=keywords><link href=https://m4xc.dev/sections/post.css rel=stylesheet><link href=https://m4xc.dev/katex/katex.min.css rel=stylesheet><script src=https://m4xc.dev/katex/katex.min.js></script><script src=https://m4xc.dev/katex/render.min.js></script><script src=https://m4xc.dev/katex/hook.js></script><body><div class=gradient-bg></div><script>if(localStorage.getItem(`theme`)===`dark`){document.body.classList.add(`dark`)}else if(localStorage.getItem(`theme`)===`light`){document.body.classList.remove(`dark`)}else if(window.matchMedia(`(prefers-color-scheme: dark)`).matches){document.body.classList.add(`dark`)};const toggleDark=()=>{let a=`dark`;document.body.classList.toggle(a);localStorage.setItem(`theme`,document.body.classList.contains(a)?a:`light`)}</script><div class=navbar><div class=bar><h3 class=title>MΛX</h3><nav><a href=https://m4xc.dev/>Home</a><a href=https://m4xc.dev/articles/>Articles</a><a href=https://m4xc.dev/blog/>Blog</a></nav><div class=theme-toggle><button class=ico-btn onclick=toggleDark()><i class="ico theme"></i></button></div></div></div><main><div class=post><h1 class=post-title>Surfel Maintenance for Global Illumination</h1><span class=post-sub> 2025-01-16 • 2943 words • 15 min • Max &LTmxcop> </span><h2 id=introduction>Introduction</h2><p>Since you've found this blog post, it's likely you already know what <span class=highlight>Surfels</span> are.<br> Regardless, I will start with a brief explanation of what they are, and what we can use them for.<p>Surfels can be used to <span class=highlight>divide up</span> the surface of <span class=highlight>geometry</span> into discrete patches.<br> This is very useful for <span class=highlight>caching lighting</span> information for example in the case of Global Illumination.<p>We can see this division of the surface of geometry <span class=highlight>below</span> here, where each Surfel patch is given a random color.<div class=img2x1><div class=img><img alt="Surfels discretizing scene geometry into patches." title="Surfels discretizing scene geometry into patches." src=https://m4xc.dev/img/blog/surfel-maintenance/surfels.png width=610px><i>Surfels discretizing scene geometry into patches.</i></div><div class=img><img alt="Figure A: The parameters that make up a Surfel." title="Figure A: The parameters that make up a Surfel." src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-parameters-2.png width=550px><i>Figure A: The parameters that make up a Surfel.</i></div></div><p>The name Surfel comes from combining the words <span class=highlight>Surface & Element</span>.<br> Surfels are commonly described using 3 parameters:<ol><li><b style=color:#4dabf7>Position</b> <em>(Position on a surface)</em><li><b style=color:#40c057>Radius</b> <em>(How much area the Surfel represents on the surface)</em><li><b style=color:#ffc034>Normal</b> <em>(Normal of the surface)</em></ol><p>In <em>Figure A</em>, we can see a visual of these 3 parameters.<p>You may be wondering now <em>what are these Surfels useful for?</em><br> At it's core Surfels are a method for <span class=highlight>dividing up</span> scene geometry into discrete patches, as I mentioned above.<br> So, it is not limited to one use case only, however it is commonly used for caching lighting information for <span class=highlight>Global Illumination</span>.<div class=img2x1><div class=img><img alt="Figure B: Surfel Radiance Cascades. (by me)" title="Figure B: Surfel Radiance Cascades. (by me)" src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-radiance-cascades.png width=550px><i>Figure B: Surfel Radiance Cascades. (by me)</i></div><div class=img><img alt="Figure C: EA SEED's GIBS." title="Figure C: EA SEED's GIBS." src=https://m4xc.dev/img/blog/surfel-maintenance/ea-gibs.png width=550px><i>Figure C: EA SEED's GIBS.</i></div></div><p>I highly recommend you to check out EA SEED's <a href=https://www.ea.com/seed/news/siggraph21-global-illumination-surfels>GIBS</a> <em>(Global Illumination based on Surfels)</em><br> Their talk at <span class=highlight>SIGGRAPH 21</span> has been my primary source for information on Surfels.<p>A big advantage of Surfels as a light information cache, is that Surfels persist between frames.<br> So, we can simply <span class=highlight>accumulate</span> information within them between frames, without a need for reprojection.<p>Now that we know what a Surfel is made out of, and what we can use it for.<br> Let's dive into how I <span class=highlight>dynamically managed</span> Surfels for my Global Illumination solution specifically.<blockquote><p>There will be many small/big differences between my Surfel maintenance and that of GIBS.</blockquote><hr><h2 id=the-pipeline>The Pipeline</h2><div class=img><img alt="Figure D: Overview of the Surfel Pipeline." title="Figure D: Overview of the Surfel Pipeline." src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-pipeline.png width=800px><i>Figure D: Overview of the Surfel Pipeline.</i></div><p>Let's start with a <span class=highlight>high level overview</span> of the maintenance pipeline for a single frame.<br> As we can see in <em>Figure D</em>, the Surfel maintenance consists of 4 stages:<ol><li><b style=color:#40c057>Spawn</b> — <em>Uses the GBuffers to decide where on screen to spawn new Surfels.</em><li><b style=color:#ffc034>Transform</b> — <em>Updates the Surfel world-space positions based on the object they're attached to.</em><li><b style=color:#e599f7>Accelerate</b> — <em>Inserts Surfels into a spatial acceleration structure to accelerate lookups.</em><li><b style=color:#4dabf7>Recycle</b> — <em>Decides whether Surfels are still relevant.</em></ol><p>I marked the <b style=color:#ffc034>Transform</b> pass with a <b style=color:#ffc034>*</b> because it is technically optional.<br> Due to time constraints, I didn't get to implementing a <b style=color:#ffc034>Transform</b> pass myself.<br> However, I will still try to explain how one would implement it.<div class=img><img alt="Figure E: Overview of the Surfel Buffers." title="Figure E: Overview of the Surfel Buffers." src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-buffers.png width=640px><i>Figure E: Overview of the Surfel Buffers.</i></div><p>The pipeline also needs a place to store all the <span class=highlight>Surfel data</span> of course.<br> We allocate these buffers upfront, with a <span class=highlight>fixed maximum</span> number of live Surfels in the scene at once.<br> I will go into more detail about the buffers in the sections below.<p>Now that we have an idea of how the pipeline fits together, let's dive into <span class=highlight>the details</span> of each pass.<hr><h3 id=surfel-acceleration>Surfel Acceleration</h3><p>In many cases we want to <span class=highlight>find Surfels</span> around a given position.<br> For example, when spawning Surfels we want to know if there are already Surfels nearby.<br> Or when recycling we want to know if there are too many Surfels nearby.<h4 id=spatial-acceleration-structures>Spatial Acceleration Structures</h4><p>In order to do this quickly, we need a spatial acceleration structure.<br> I'm going to cover a few options which I personally investigated:<ol><li>Uniform Grid <em>(The most basic structure)</em><li>Trapezoidal Grid <em>(Used by GIBS)</em><li>Multi-level Hash Grid <em>(What I ended up using)</em></ol><p>I initially began by using a <span class=highlight>3D uniform grid</span>, for me that was a good starting point.<br> However, it scales very poorly when you want larger scenes, and when your Surfels are relatively small.<div class=img><img alt="Figure F: Trapezoidal grid structure used by GIBS." title="Figure F: Trapezoidal grid structure used by GIBS." src=https://m4xc.dev/img/blog/surfel-maintenance/trapezoidal-grid.png width=480px><i>Figure F: Trapezoidal grid structure used by GIBS.</i></div><p><span class=highlight>GIBS</span> combines a small uniform grid centered on the camera with <span class=highlight>trapezoidal grids</span> extending outwards.<br> This gets you very fast lookups, as the trapezoidal grids are simply uniform grids with a non-linear transform.<br> However, I instead decided on using a <span class=highlight>multi-level hash grid</span>, so I never implemented this scheme.<div class=img><img alt="Figure G: Heatmap view of the multi-level hash grid." title="Figure G: Heatmap view of the multi-level hash grid." src=https://m4xc.dev/img/blog/surfel-maintenance/multi-level-hash-grid.png width=640px><i>Figure G: Heatmap view of the multi-level hash grid.</i></div><p>The multi-level hash grid is relatively simple, it is a normal hash grid storing a <code>uint</code> for each cell.<br> Cell hashes are created by combining a <span class=highlight>grid position</span> & <span class=highlight>grid level</span>, I used 9 bits for each axis and 5 bits for the level.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Hash a Surfel grid location. (XYZ9L5) */
</span><span style=color:#95cc5e>uint </span><span style=color:#60a365>surfel_hash_function</span><span>(</span><span style=color:#db784d>const </span><span style=color:#95cc5e>uvec3 </span><span style=color:#f8bb39;font-style:italic>loc</span><span>, </span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint </span><span style=color:#f8bb39;font-style:italic>level</span><span>) {
</span><span>    </span><span style=color:#db784d>return </span><span style=color:#207241>xxhash32</span><span>(((loc.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>% </span><span style=color:#eaae2e>512u</span><span>) </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>9u </span><span style=color:#db784d>* </span><span style=color:#eaae2e>0u</span><span>))
</span><span>                  </span><span style=color:#db784d>| </span><span>((loc.</span><span style=color:#f8bb39>y </span><span style=color:#db784d>% </span><span style=color:#eaae2e>512u</span><span>) </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>9u </span><span style=color:#db784d>* </span><span style=color:#eaae2e>1u</span><span>))
</span><span>                  </span><span style=color:#db784d>| </span><span>((loc.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>% </span><span style=color:#eaae2e>512u</span><span>) </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>9u </span><span style=color:#db784d>* </span><span style=color:#eaae2e>2u</span><span>))
</span><span>                  </span><span style=color:#db784d>| </span><span>((level </span><span style=color:#db784d>&  </span><span style=color:#eaae2e>31u</span><span>) </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>9u </span><span style=color:#db784d>* </span><span style=color:#eaae2e>3u</span><span>)));
</span><span>}
</span></code></pre><blockquote><p>The grid level is determined using a logarithm of the distance squared to the camera.</blockquote><blockquote><p>For each live Surfel the <span class=highlight>acceleration pass</span> will insert the Surfel into all cells it overlaps.<br> It's also very important here to be aware of the grid <span class=highlight>level transitions</span>, on which you need to insert the Surfel into both levels.</blockquote><h4 id=filling-the-structure>Filling the Structure</h4><p>I mentioned how each grid cell only stores a <code>uint</code>, this is key to making the structure memory efficient.<br> Surfels are represented by a <span class=highlight>unique ID</span>, however we do not want to store those directly in the grid cells.<br> Instead we want each grid cell to store an index into a <span class=highlight>list of Surfel IDs</span>.<blockquote><p>This unique ID we use to refer a Surfel is also the index inside the buffers where it's data is located.</blockquote><p>To achieve this, we will need <span class=highlight>multiple passes</span> for filling the acceleration structure.<br> This <span class=highlight>applies to all</span> the acceleration structure variants I described above.<div class=img><img alt="Figure H: Visualization of the grid & list structure." title="Figure H: Visualization of the grid & list structure." src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-grid-list.png width=640px><i>Figure H: Visualization of the grid & list structure.</i></div><p>As we can see in <em>Figure H</em>, the idea is that after the passes, the grid buffer points to a <span class=highlight>range of elements</span> in the Surfel list buffer.<br> Because a Surfel can be in multiple cells, the Surfel list can contain <span class=highlight>duplicate IDs</span>.<p>To achieve this, I used the following 3 passes:<ol><li><span class=highlight>Surfel counting</span> <em>(for each Surfel, increment the <code>uint</code> inside each cell it overlaps)</em><li><span class=highlight>Prefix sum</span> <em>(perform a prefix sum over the entire grid buffer)</em><li><span class=highlight>Surfel insertion</span> <em>(for each Surfel, decrement the <code>uint</code> inside each cell it overlaps and write the Surfel ID into the Surfel list)</em></ol><blockquote><p>When looping over the Surfels, we always loop over the entire Surfel buffer.<br> If the <em>radius</em> of a Surfel is 0 we know the Surfel is not live, so we can return early.</blockquote><pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* <===> Pass 1 <===> */
</span><span style=color:#db784d>for </span><span>(surfels) </span><span style=color:#db784d>for </span><span>(overlapping cells) {
</span><span>    </span><span style=color:#7a7267>/* Increment the atomic counter in the hash grid cell */
</span><span>    </span><span style=color:#207241>atomicAdd</span><span>(surfel_grid[</span><span style=color:#207241>surfel_hash_function</span><span>(...) </span><span style=color:#db784d>%</span><span> grid_capacity], </span><span style=color:#eaae2e>1</span><span>);
</span><span>}
</span><span>
</span><span style=color:#7a7267>/* <===> Pass 2 <===> */
</span><span style=color:#7a7267>/* Perform a inclusive prefix sum on the grid buffer */
</span><span>
</span><span style=color:#7a7267>/* <===> Pass 3 <===> */
</span><span style=color:#db784d>for </span><span>(surfels) </span><span style=color:#db784d>for </span><span>(overlapping cells) {
</span><span>    </span><span style=color:#7a7267>/* Decrement the atomic counter in the hash grid cell */
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> offset </span><span style=color:#db784d>= </span><span style=color:#207241>atomicAdd</span><span>(surfel_grid[</span><span style=color:#207241>surfel_hash_function</span><span>(...) </span><span style=color:#db784d>%</span><span> grid_capacity], </span><span style=color:#db784d>-</span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>- </span><span style=color:#eaae2e>1u</span><span>;
</span><span>    surfel_list[offset] </span><span style=color:#db784d>=</span><span> surfel_ptr; </span><span style=color:#7a7267>/* &LT- Insert the Surfel ID into the Surfel list */
</span><span>}
</span></code></pre><blockquote><p>It's very important here to be aware of the grid <span class=highlight>level transitions</span> while counting & inserting.<br> On the transitions you have to insert Surfels into both grid levels.</blockquote><p>After this you will now be able to <span class=highlight>quickly</span> find nearby Surfels with no limit of the bounds of your scene.<br> However, it is important to note, hash grids experience <span class=highlight>hash collisions</span>.<br> So we have to <span class=highlight>be aware</span> that you might sometimes get Surfels which are actually very far away.<hr><h3 id=surfel-spawning>Surfel Spawning</h3><p>When spawning Surfels we spawn them from the <span class=highlight>GBuffer</span>, depth & normals.<br> The <span class=highlight>tricky part</span> is avoiding spawning Surfels too close to each other.<p>The way we combat that is by splitting the screen into <span class=highlight>16x16</span> pixel tiles.<br> Each tile will find the pixel within itself which has the least Surfel coverage.<br> If that coverage is below a certain <span class=highlight>threshold</span>, we will spawn a new Surfel on that pixel.<blockquote><p>You may want to choose a different tile size, depending on the size of your Surfels.</blockquote><h4 id=coverage-testing>Coverage Testing</h4><p>We can check the coverage for a pixel by checking the <span class=highlight>acceleration structure</span> of the <em>previous frame</em> at the position of the pixel:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Location in world-space visible through this pixel */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>vec3</span><span> pixel_pos </span><span style=color:#db784d>=</span><span> camera_pos </span><span style=color:#db784d>+</span><span> pixel_dir </span><span style=color:#db784d>*</span><span> pixel_depth;
</span><span>
</span><span style=color:#7a7267>/* Grab the start & end indices for this pixel's hash cell */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> hashkey </span><span style=color:#db784d>= </span><span style=color:#207241>surfel_pos_hash</span><span>(pixel_pos, camera_pos) </span><span style=color:#db784d>%</span><span> grid_capacity;
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> start </span><span style=color:#db784d>=</span><span> surfel_grid[hashkey], end </span><span style=color:#db784d>=</span><span> surfel_grid[hashkey </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>1u</span><span>];
</span><span>
</span><span style=color:#95cc5e>float</span><span> coverage </span><span style=color:#db784d>= </span><span style=color:#eaae2e>1e30</span><span>;
</span><span style=color:#db784d>for </span><span>(</span><span style=color:#95cc5e>uint</span><span> i </span><span style=color:#db784d>=</span><span> start; i </span><span style=color:#db784d><</span><span> end; </span><span style=color:#db784d>++</span><span>i) {
</span><span>    </span><span style=color:#7a7267>/* Grab the Surfel ID from the List */
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> surfel_ptr </span><span style=color:#db784d>=</span><span> surfel_list[i];
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Use the Surfel ID to fetch it's position & radius */
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>vec3</span><span>  p </span><span style=color:#db784d>=</span><span> surfel_pos[surfel_ptr];
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>float</span><span> r </span><span style=color:#db784d>=</span><span> surfel_radius[surfel_ptr];
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Find the highest coverage */
</span><span>    coverage </span><span style=color:#db784d>= </span><span style=color:#95cc5e>max</span><span>(coverage, </span><span style=color:#207241>point_coverage</span><span>(pixel_pos, p, r));
</span><span>}
</span></code></pre><blockquote><p><code>surfel_pos_hash(...)</code> finds the grid position, level, and feeds those into <code>surfel_hash_function(...)</code>.</blockquote><p>Now, in order to efficiently <span class=highlight>communicate</span> across the 16x16 tile of pixels on the GPU we can use <span class=highlight>group shared memory</span>.<br> The idea is simple, we have a single <code>uint</code> as group shared memory, groups are 16x16 lanes in size.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#db784d>coherent </span><span style=color:#95cc5e>uint</span><span> gs_candidate;
</span></code></pre><p>Each lane corresponds to a pixel in a 16x16 tile, and will combine its coverage & local index into a <code>uint</code>:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Compound the pixel coverage & pixel index within its 16x16 tile into a uint */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> score </span><span style=color:#db784d>= </span><span style=color:#95cc5e>min</span><span>(</span><span style=color:#eaae2e>65535u</span><span>, (</span><span style=color:#95cc5e>uint</span><span>)(coverage </span><span style=color:#db784d>* </span><span style=color:#eaae2e>1000.0</span><span>));
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> candidate </span><span style=color:#db784d>= </span><span>((score </span><span style=color:#db784d><< </span><span style=color:#eaae2e>16u</span><span>) </span><span style=color:#db784d>& </span><span style=color:#eaae2e>0xffff0000</span><span>) </span><span style=color:#db784d>| </span><span>(local_idx </span><span style=color:#db784d>& </span><span style=color:#eaae2e>0x0000ffff</span><span>);
</span></code></pre><p>The reason we add the local index is make each pixel have a unique <code>uint</code>.<br> Because, now we're going to perform an <span class=highlight>atomic minimum</span> on that group shared <code>uint</code>.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span>gs_candidate </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0xFFFFFFFF</span><span>; </span><span style=color:#7a7267>/* Reset the groupshared candidate */
</span><span style=color:#207241>barrier</span><span>();
</span><span>
</span><span style=color:#7a7267>/* Find the pixel with the lowest coverage in this group */
</span><span style=color:#207241>atomicMin</span><span>(gs_candidate, candidate);
</span><span style=color:#207241>barrier</span><span>();
</span></code></pre><p>Now, after this <span class=highlight>memory barrier</span> we can check if our pixel was the one with the least coverage:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#db784d>if </span><span>(gs_candidate </span><span style=color:#db784d>==</span><span> candidate) {
</span><span>    </span><span style=color:#7a7267>/* Spawn Surfel if the coverage is below the threshold... */
</span><span>}
</span></code></pre><h4 id=spawning-surfels>Spawning Surfels</h4><p>We now know which pixels want to spawn a Surfel without causing much overlap.<br> So, let's have a look at how exactly we spawn Surfels.<p>This is where the <span class=highlight>Surfel Stack</span> buffer comes into play.<div class=img><img alt="Figure I: Visualization of spawning a Surfel using the Stack." title="Figure I: Visualization of spawning a Surfel using the Stack." src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-spawning.png width=960px><i>Figure I: Visualization of spawning a Surfel using the Stack.</i></div><p>First of all, as we can see in <em>Figure I</em>, the Surfel Stack has to start out filled with all unique Surfel IDs.<br> The order in which they are placed doesn't matter, as long as they're <span class=highlight>all unique</span>.<p>We can see the spawning sequence in <em>Figure I</em>, we simply increment the Surfel Stack pointer.<br> And use the unique ID in the stack as the <span class=highlight>Surfel ID</span> which we can write data into:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Pop the Surfel Stack (atomic) */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> stack_ptr </span><span style=color:#db784d>= </span><span style=color:#207241>atomicAdd</span><span>(surfel_stack_pointer, </span><span style=color:#eaae2e>1</span><span>);
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> surfel_ptr </span><span style=color:#db784d>=</span><span> surfel_stack[stack_ptr];
</span><span>
</span><span style=color:#7a7267>/* Write our new Surfel data into the Surfel buffers */
</span><span>surfel_pos[surfel_ptr] </span><span style=color:#db784d>=</span><span> ...;
</span><span>surfel_radius[surfel_ptr] </span><span style=color:#db784d>=</span><span> ...;
</span></code></pre><blockquote><p>For simplicity I left out the bounds check here, but you should make sure the stack isn't full!</blockquote><h4 id=spawning-optimization>Spawning Optimization</h4><p>Because I am managing multiple sets of Surfels, spawning can get pretty expensive.<br> An optimization I came up with is to only <span class=highlight>check 1/4</span> of the pixels for coverage each frame.<br> Cycling through a 2x2 tile of pixels every 4 frames.<p>On my <span class=highlight>AMD Radeon 890M iGPU</span> this resulted in the total time spend spawning going from:<br> <code>~6ms</code> -> <code>~1ms</code>, which is a rather huge improvement, without losing any significant quality.<hr><h3 id=surfel-recycling>Surfel Recycling</h3><p>If all we do is spawn new Surfels, we will quickly run out of our <span class=highlight>Surfel budget</span>.<br> Lucky for us, most Surfels can be recycled after a while, when they are no longer relevant.<h4 id=recycling-heuristic>Recycling Heuristic</h4><p>The way we decide whether to recycle a Surfel is based on a <span class=highlight>heuristic</span>.<br> This heuristic is usually a combination of a few different parameters:<ol><li>Time since used <em>(Last time when the Surfel was sampled)</em><li>Surfel coverage <em>(How many Surfels are nearby)</em><li>Live Surfel count <em>(How many Surfels are currently in use)</em></ol><p>To find the Surfel <span class=highlight>coverage</span> we can use the same method we used during spawning to find the coverage.<br> The time since used can be stored on the Surfel, to always be incremented during the recycling pass.<br> We can <span class=highlight>reset that time</span> every time we sample the Surfel's lighting information.<p>Once we have the heuristic, we can use it as a <span class=highlight>random chance</span> for recycling.<br> Or we can use it as a threshold for deterministic recycling.<h4 id=despawning-surfels>Despawning Surfels</h4><p>If we decide to recycle a Surfel we'll have to <span class=highlight>push</span> it back onto the <span class=highlight>Surfel Stack</span>.<div class=img><img alt="Figure J: Visualization of recycling a Surfel using the Stack." title="Figure J: Visualization of recycling a Surfel using the Stack." src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-recycling.png width=640px><i>Figure J: Visualization of recycling a Surfel using the Stack.</i></div><p>All Surfel IDs to the right of the Surfel Stack pointer will always be <span class=highlight>unique IDs</span> to unused Surfel Data.<br> To maintain that while recycling, we can decrement the Surfel Stack pointer, and write out Surfel ID into the Stack slot that just opened up.<br> We can see this <span class=highlight>sequence</span> in <em>Figure J</em> where we recycle Surfel ID <code>8</code> by pushing it back onto the Surfel Stack.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* First set the recycled Surfel's radius to 0.0, marking it as unused */
</span><span>surfel_radius[surfel_ptr] </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0.0</span><span>;
</span><span>
</span><span style=color:#7a7267>/* Then decrement the stack pointer & write the Surfel ID into the open slot */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> slot </span><span style=color:#db784d>= </span><span style=color:#207241>atomicAdd</span><span>(surfel_stack_pointer, </span><span style=color:#db784d>-</span><span style=color:#eaae2e>1</span><span>) </span><span style=color:#db784d>- </span><span style=color:#eaae2e>1u</span><span>;
</span><span>surfel_stack[slot] </span><span style=color:#db784d>=</span><span> surfel_ptr;
</span></code></pre><p>As mentioned ealier, the <span class=highlight>radius</span> is also used when looping over all Surfels to check if the Surfel is <span class=highlight>live</span>.<br> This also allows us to early out during the recycling pass for example:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Compute kernel executed for each Surfel in Surfel Data */
</span><span style=color:#95cc5e>void </span><span style=color:#60a365>main</span><span>(</span><span style=color:#95cc5e>uint </span><span style=color:#f8bb39;font-style:italic>thread_id</span><span>) {
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>uint</span><span> surfel_ptr </span><span style=color:#db784d>=</span><span> thread_id;
</span><span>
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>float</span><span> radius </span><span style=color:#db784d>=</span><span> surfel_radius[surfel_ptr];
</span><span>    </span><span style=color:#db784d>if </span><span>(radius </span><span style=color:#db784d>== </span><span style=color:#eaae2e>0.0</span><span>) </span><span style=color:#db784d>return</span><span>; </span><span style=color:#7a7267>/* Early out if this Surfel is not live */
</span><span>
</span><span>    </span><span style=color:#7a7267>/* ... */
</span><span>}
</span></code></pre><hr><h3 id=surfel-transformation>Surfel Transformation</h3><p>During the spawning sequence, when we place Surfels we're currently doing so in <span class=highlight>world-space</span>.<br> Which means that Surfels won't move with the geometry that they're supposed to be attached to.<h4 id=transform-buffer>Transform Buffer</h4><p>Ideally we want to instead attach Surfels to the model matrix <em>(transform)</em> of objects in the scene paired with a <span class=highlight>local</span> position.<br> This is what <span class=highlight>GIBS</span> does, they have a buffer filled with the <span class=highlight>transforms</span> of all objects in the scene.<br> When spawning a new Surfel, they assign that Surfel the transform ID of the object they are spawning on.<br> Which points to the model matrix of that object in the global <span class=highlight>transform buffer</span>.<div class=img><img alt="Figure K: Transform ID Gbuffer from GIBS." title="Figure K: Transform ID Gbuffer from GIBS." src=https://m4xc.dev/img/blog/surfel-maintenance/gibs-transform-gbuffer.png width=640px><i>Figure K: Transform ID Gbuffer from GIBS.</i></div><p>To know what transform a Surfel should be attached to when spawning, GIBS has a transform ID <span class=highlight>Gbuffer</span>.<br> We can see a <span class=highlight>debug view</span> of this in <em>Figure K</em>, each color represents a different transform ID.<blockquote><p>Unfortunately I cannot go into more detail on this part of the pipeline, because I personally skipped it due to time constraints.</blockquote><hr><h2 id=performance>Performance</h2><p>We're almost at the end of the blog post now, so let's look at some <span class=highlight>performance measurements</span>.<br> Keep in mind that these timings are for <span class=highlight>6</span> individual Cascades of Surfels, so you can expect timings normally to be better.<blockquote><p>Each Surfel Cascade has <code>1/4</code> the Surfel count of the previous one, with the first having <code>262.144</code> Surfels at most.</blockquote><div class=img><img alt="Figure L: Captured on AMD 890M iGPU. (6 Surfel Cascades)" title="Figure L: Captured on AMD 890M iGPU. (6 Surfel Cascades)" src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-performance-890m.png width=960px><i>Figure L: Captured on AMD 890M iGPU. (6 Surfel Cascades)</i></div><p>First, here's the performance on my <span class=highlight>AMD Radeon 890M</span> integrated GPU, we can see that the hash insertion <em>(Surfel Insertion)</em> is the most expensive part.<br> This is because it requires us to wait for an <span class=highlight>atomic operation</span> to complete, because we need to know which Surfel List index to insert the Surfel into.<br> Besides that, I'd argue the performance is quite good, especially because this is maintaining 6 sets of Surfels.<div class=img><img alt="Figure M: Captured on RTX 4070 Mobile. (6 Surfel Cascades)" title="Figure M: Captured on RTX 4070 Mobile. (6 Surfel Cascades)" src=https://m4xc.dev/img/blog/surfel-maintenance/surfel-performance-4070.png width=960px><i>Figure M: Captured on RTX 4070 Mobile. (6 Surfel Cascades)</i></div><p>Now let's look at the performance on my <span class=highlight>NVIDIA RTX 4070</span> Mobile GPU.<br> We can see here that the hash insertion has gone down quite a bit, and now the <span class=highlight>recycling pass</span> is actually the most expensive pass.<br> However, again I'd argue the <span class=highlight>overhead</span> of maintenance is <span class=highlight>relatively small</span> here.<hr><h2 id=conclusion>Conclusion</h2><p>To round this off, we've looked at how we can maintain a large number of Surfels in an efficient manor.<br> We took a <span class=highlight>high level</span> overview of the entire pipeline, and then went into the <span class=highlight>details</span> of each maintenance pass.<br> And in the end we briefly looked at performance on 2 modern GPUs.<p>It took me quite some research and <span class=highlight>trail & error</span> to figure out some of the details.<br> So, I hope this blog post sheds some more light on the details of how to maintain Surfels.<h3 id=resources>Resources</h3><p>Here's a few resources which helped me on my <span class=highlight>Surfel journey</span> :)<ul><li>Hybrid Rendering for Real-Time Ray Tracing <a href=https://media.contentapi.ea.com/content/dam/ea/seed/presentations/2019-ray-tracing-gems-chapter-25-barre-brisebois-et-al.pdf>Ray Tracing Gems 2019</a>.<li>SIGGRAPH 2021, GIBS <a href=https://youtu.be/h1ocYFrtsM4>https://youtu.be/h1ocYFrtsM4</a>.<li>Surfel GI implementation in <code>kajiya</code> by Tomasz <a href=https://github.com/h3r2tic/kajiya>https://github.com/h3r2tic/kajiya</a></ul></div><footer class=site-footer><p class=end-msg id=end-msg>---- Thanks for reading! ----</p><i>© 2020-<span id=year>2024</span> Max &LTmxcop>, All rights reserved</i></footer><script>const end_msg=document.getElementById(`end-msg`);const msg_idx=Math.floor(Math.random()*3);const msg_arr=[`Thank you for reading!`,`Hope you enjoyed the content!`,`Have a great day!`];end_msg.innerText=`---- `+ msg_arr[msg_idx]+ ` ----`;const year_el=document.getElementById(`year`);year_el.innerText=new Date().getFullYear()</script></main><script src=https://m4xc.dev/autoplay.js></script>