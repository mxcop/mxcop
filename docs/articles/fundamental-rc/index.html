<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><title>MΛX - Fundamentals of Radiance Cascades</title><meta content="© 2020-2024 Max <mxcop>, All rights reserved" name=copyright><meta content="I've worked with Radiance Cascades for some time now, this is a deep-dive into the fundamentals." name=description><meta content=https://m4xc.dev/img/articles/fundamental-rc/splash.png itemprop=image><meta content=https://m4xc.dev/ property=og:url><meta content=website property=og:type><meta content=https://m4xc.dev/img/articles/fundamental-rc/splash.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=https://m4xc.dev/img/articles/fundamental-rc/splash.png name=twitter:image><link href=https://m4xc.dev/general.css rel=stylesheet><meta content="Max <mxcop>" name=author><meta content="graphics, radiance cascades" name=keywords><link href=https://m4xc.dev/sections/post.css rel=stylesheet><link href=https://m4xc.dev/katex/katex.min.css rel=stylesheet><script src=https://m4xc.dev/katex/katex.min.js></script><script src=https://m4xc.dev/katex/render.min.js></script><script src=https://m4xc.dev/katex/hook.js></script><body><div class=gradient-bg></div><script>if(localStorage.getItem(`theme`)===`dark`){document.body.classList.add(`dark`)}else if(localStorage.getItem(`theme`)===`light`){document.body.classList.remove(`dark`)}else if(window.matchMedia(`(prefers-color-scheme: dark)`).matches){document.body.classList.add(`dark`)};const toggleDark=()=>{let a=`dark`;document.body.classList.toggle(a);localStorage.setItem(`theme`,document.body.classList.contains(a)?a:`light`)}</script><div class=navbar><div class=bar><h3 class=title>MΛX</h3><nav><a href=https://m4xc.dev/>Home</a><a href=https://m4xc.dev/articles/>Articles</a></nav><div class=theme-toggle><button class=ico-btn onclick=toggleDark()><i class="ico theme"></i></button></div></div></div><main><div class=post><h1 class=post-title>Fundamentals of Radiance Cascades</h1><span class=post-sub> 2024-10-22 • 3683 words • 19 min • Max &LTmxcop> </span><h2 id=introduction>Introduction</h2><p>In this article I'm going to share my understanding of the fudamentals of Radiance Cascades. <em>(abbreviated as RC)</em><br> At it's core, Radiance Cascades is a method for efficiently representing a <span class=highlight>radiance field</span>,<br> allowing us to represent the <span class=highlight>incoming light</span> from/around some area at any point in that area.<br> In 2D that area is usually the screen.<blockquote><p>For the sake of simplicity I will explain everything in 2D, however RC can be expanded into 3D aswell.<br> I will also assume the reader has a rudimentary understanding of ray tracing & the concept of irradiance probes.</blockquote><p>So, what can RC in 2D <em>(also referred to as Flatland)</em> achieve?<br> My implementation is able to compute <span class=highlight>diffuse global illumination</span> in real-time:<div class=video><video autoplay class=video loop muted playsinline preload=none style=width:640px><source src=https://m4xc.dev/anim/articles/fundamental-rc/showcase.mp4 type=video/mp4> Video tag is not supported.</video><i>Diffuse global illumination in flatland.</i></div><p>An awesome property of this method is that this is done <span class=highlight>fully-deterministically</span> and without temporal re-use!<br> Furthermore, there are already plenty of clever ways to get its performance to acceptable levels for modern hardware.<p><em>So without further ado, let's dive in!</em><hr><h2 id=observations>Observations</h2><p>Radiance Cascades is build on <strong>two</strong> key observations.<br> So first, let's observe these together, and have a <span class=highlight>short recap</span> afterwards.<h3 id=angular-observation>Angular Observation</h3><div class=video><video autoplay class=video loop muted playsinline preload=none style=width:540px><source src=https://m4xc.dev/anim/articles/fundamental-rc/angular-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure A: Circular object with a radiance probe.</i></div><p><em>Figure A</em>, depicts a <span class=highlight>circular object</span> on the left, with a radiance probe to the right of it.<br> The radiance probe has an angular resolution which can be defined as the angle between its evenly spaced rays. <em>(Shown in blue)</em><br> As the radiance probe moves <span class=highlight>further away</span> from the light source, we can see that its <span class=highlight>angular resolution</span> becomes insufficient.<p>What we can observe here is that the angle between rays we can get away with for a probe, depends on <strong>two</strong> factors:<ol><li>$ D $ The <span class=highlight>distance</span> to the furthest object.<li>$ w $ The <span class=highlight>size</span> of the smallest object.</ol><p>In the <a href=https://github.com/Raikiri/RadianceCascadesPaper>paper</a> this restriction is formalized with this equation: $ \Delta_\omega < w/D $<br> Which states that the angle between our evenly spaced rays $ \Delta_\omega $ should be smaller than $ w/D $.<h3 id=spatial-observation>Spatial Observation</h3><div class=video><video autoplay class=video loop muted playsinline preload=none style=width:540px><source src=https://m4xc.dev/anim/articles/fundamental-rc/spatial-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure B: Penumbra created by line light and line occluder.</i></div><p><em>Figure B</em>, shows that we can resolve a penumbra by <span class=highlight>interpolating</span> between only 2 probes. <em>(Shown as blue dots)</em><br> The spacing of these probes can be increased the further away we get from all objects in the scene.<p>We can observe that the probe spacing is dependent on <strong>two</strong> factors:<ol><li>$ D $ The <span class=highlight>distance</span> to the closest object.<li>$ w $ The <span class=highlight>size</span> of the smallest object.</ol><blockquote><p>Does that not sound familiar?</blockquote><p>The <span class=highlight>distance</span> is the <strong>inverse</strong> of the angular observation!<div class=video><video autoplay class=video loop muted playsinline preload=none style=width:540px><source src=https://m4xc.dev/anim/articles/fundamental-rc/penumbra-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure C: Moving the line occluder around.</i></div><p><em>Figure C</em>, shows that regardless of the distance between the light and the occluder, the penumbra still <span class=highlight>grows with distance</span>.<br> However, the sharpness of the penumbra changes, RC is notoriously bad at representing <em>very</em> sharp shadows.<p><em>Figure C</em>, also serves to <span class=highlight>highlight</span> that we're interested in the nearest or furthest object, <strong>not light source</strong>.<br> <em>At the end of the day, a wall is just a light source that emits no light, and a light source is just a wall that emits light.</em><h3 id=penumbra-condition-theorem>Penumbra Condition / Theorem</h3><p>While the required angle between rays ($ \Delta_\omega $) decreases, the required distance between probes ($ \Delta_p $) increases and vice versa.<br> They are <span class=highlight>inversely proportional</span>.<p>In the <a href=https://github.com/Raikiri/RadianceCascadesPaper>paper</a> this relationship is formalized as the <span class=highlight>penumbra condition</span> with this equation:<p>$ \begin{cases} \Delta_p <\sim D, \\ \Delta_\omega <\sim 1/D \end{cases} $<blockquote><p>$ A <\sim B $ means that; $ A $ is less than the output of some function, which scales linearly with $ B $.</blockquote><p>$ w $ <em>(the size of the smallest object)</em> is not included in the <span class=highlight>penumbra condition</span> because it is the same at all points in the scene.<br> We can also observe that the required angular & spatial resolution both increase when $ w $ decreases.<br> Because we need higher resolution for both in order to resolve the smallest object in the scene.<h3 id=recap>Recap</h3><p>Ok, these <span class=highlight>observations</span> took me some time to <em>wrap my head around</em> but they're key to understanding RC.<br> <em>So let's quickly reiterate our observations.</em><p>What we've <span class=highlight>observed</span> is that the <strong>further</strong> we are from the closest object in the scene:<ol><li>The <strong>less</strong> spatial resolution we need. <em>(e.g. the <span class=highlight>larger spacing</span> can be between probes)</em><li>The <strong>more</strong> angular resolution we need. <em>(e.g. the <span class=highlight>more rays</span> we need per probe)</em></ol><hr><h2 id=exploiting-observations>Exploiting Observations</h2><p>Now that we've made the observations and defined the penumbra theorem, let's look at how we can <span class=highlight>exploit</span> these observations.<h3 id=angular>Angular</h3><p>We've got a <strong>problem</strong>: classic probes we're all used to, can hit objects at <span class=highlight>virtually any distance</span>.<br> In order to exploit the <span class=highlight>penumbra theorem</span> we need some way to <em>narrow</em> this possible <span class=highlight>distance window</span>.<div class=video><video autoplay class=video loop muted playsinline preload=none style=width:360px><source src=https://m4xc.dev/anim/articles/fundamental-rc/splitting-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure D: Probe being split into “rings”.</i></div><p><em>Figure D</em>, shows one way of narrowing this window, we can discretize our circular probes into rings.<br> By doing this we <strong>not only</strong> know that each ring will hit within a narrow distance window,<br> we can also <span class=highlight>vary</span> the <span class=highlight>angular resolution</span> between rings!<blockquote><p>These new rays with a limited range, are referred to as <strong>intervals</strong>.</blockquote><p>This is exactly what we're looking for to <span class=highlight>exploit</span> the <span class=highlight>angular part</span> of the penumbra theorem.<br> We can increase the interval count <em>(aka, decrease the angle between rays)</em> with each consecutive ring that hits objects further away.<div class=img><img alt="Figure E: Increasing angular resolution for more distant “rings”." title="Figure E: Increasing angular resolution for more distant “rings”." src=https://m4xc.dev/img/articles/fundamental-rc/inc-angular-split.png width=360px><i>Figure E: Increasing angular resolution for more distant “rings”.</i></div><p>In order to still <span class=highlight>capture</span> our entire scene, we will have many of these <em>rings</em>.<p>In the example in <em>Figure E</em>, we increase the interval count by <strong>2x</strong> with every consecutive ring.<br> Which let's us increase the <span class=highlight>distance window</span> of each ring <em>(the length of its intervals)</em> by that same factor.<br> This ensures the <span class=highlight>gap</span> between intervals remains <em>approximately</em> equal between rings.<h3 id=spatial>Spatial</h3><p>So far, with the angular observation we haven't really achieved any <span class=highlight>reduction</span> in ray count.<br> We're still casting a <span class=highlight>very large number</span> of rays for each probe using this method, <em>good thing that's about to change.</em><p>This is when we <span class=highlight>drop the idea</span> that these rings together make up a <strong>single</strong> probe.<br> Instead, let's view each consecutive ring as its own probe, which <em>can be moved</em>.<blockquote><p>From now on when we refer to <strong>probes</strong>, we are referring to <strong>rings</strong>.</blockquote><div class=video><video autoplay class=video loop muted playsinline preload=none style=width:360px><source src=https://m4xc.dev/anim/articles/fundamental-rc/spatial-exploit-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure F: Increasing probe/ring spacing.</i></div><blockquote><p>The length of the intervals in <em>Figure F</em> is <strong>incorrect</strong>, this is to make them easier on the eyes.</blockquote><p><em>Figure F</em>, shows one way we can use this new <span class=highlight>perspective</span> on the probes.<br> We saw during the spatial observation that when objects are <span class=highlight>further away</span>, we can have <span class=highlight>larger spacing</span> between probes.<p>So, when our <span class=highlight>distance window</span> gets further and further away, we may increase the <span class=highlight>spacing</span> between those probes.<br> And because we're trying to fill some <span class=highlight>area</span> with them, this means we need less of them.<p>There is a visible <span class=highlight>disconnect</span> between probes between cascades, this <em>does</em> result in artifacts, mainly <em>ringing</em>.<blockquote><p>There are fixes out there <em>(e.g. bilinear & parallax fix)</em>, however they're out of the scope of this article.</blockquote><hr><h2 id=cascades>Cascades</h2><p>Now that we understand how we can exploit the <strong>two</strong> key observations.<br> Let's put the <strong>two</strong> together and finally define what exactly a <span class=highlight>cascade</span> is!<div class=img2x1><div class=img><img alt="Figure G1: Cascade 0, with 4x4 probes." title="Figure G1: Cascade 0, with 4x4 probes." src=https://m4xc.dev/img/articles/fundamental-rc/cascade0.png width=360px><i>Figure G1: Cascade 0, with 4x4 probes.</i></div><div class=img><img alt="Figure G2: Cascade 1, with 2x2 probes." title="Figure G2: Cascade 1, with 2x2 probes." src=https://m4xc.dev/img/articles/fundamental-rc/cascade1.png width=360px><i>Figure G2: Cascade 1, with 2x2 probes.</i></div></div><p>A cascade is basically a <span class=highlight>grid of probes</span>, in which all probes have <strong>equal</strong> properties.<br> <em>(e.g. interval count, interval length, probe spacing)</em><p>The reason we call them cascades is because they <span class=highlight>cascade outwards</span> with increasing interval count and length.<br> <em>Or at least, that's how I like to think about it.</em><h3 id=cascade-hierarchy>Cascade Hierarchy</h3><p>A cascade <span class=highlight>on its own</span> isn't super useful, only capturing a small part of the scene.<br> Many cascades together is what we're really after, we want to <strong>combine</strong> them into a hierarchy.<br> For example in <em>Figure G1 & G2</em> we can see two cascades that could make up a <span class=highlight>cascade hierarchy</span>.<p>Most of the time, for <span class=highlight>simplicity</span> sake we will decrease probe count between cascades by <strong>2x</strong> along each axis.<br> Like we've seen also in <em>Figure G1 & G2</em>, we will find out why this is convenient <em>later</em> on in this article.<p>If we're following the <span class=highlight>penumbra condition</span>, the spatial and angular resolution should be <strong>inversely proportional</strong>.<br> So if we increase probe spacing by <strong>2x</strong> we need to decrease the angle between intervals by <strong>2x</strong> as well.<blockquote><p>However, there's also many implementation which decrease the angle between intervals by <strong>4x</strong> instead.<br> It is more costly, but it may produce higher quality results in some cases.</blockquote><h3 id=cascade-memory>Cascade Memory</h3><div class=video><video autoplay class=video loop muted playsinline preload=none style=width:360px><source src=https://m4xc.dev/anim/articles/fundamental-rc/probe-memory-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure H: 4x4 probe in texture memory.</i></div><p>The most common way we <span class=highlight>store probes</span> in memory is using a <strong>2D texture</strong>.<br> In <em>Figure H</em>, we can see one such probe, it has <em>16</em> intervals making it <em>4x4</em> texels in memory.<br> Each <span class=highlight>texel</span> representing a single <span class=highlight>direction</span>, indicated by the white arrow in the center.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#db784d>const </span><span style=color:#95cc5e>int</span><span> dir_count </span><span style=color:#db784d>= </span><span style=color:#eaae2e>16</span><span>; </span><span style=color:#7a7267>/* 4x4 */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>int</span><span> dir_index </span><span style=color:#db784d>=</span><span> ...;
</span><span>
</span><span style=color:#7a7267>/* Compute interval direction from direction index */
</span><span style=color:#95cc5e>float</span><span> angle </span><span style=color:#db784d>= </span><span style=color:#eaae2e>2.0 </span><span style=color:#db784d>*</span><span> PI </span><span style=color:#db784d>* </span><span>((</span><span style=color:#95cc5e>float</span><span>(dir_index) </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>0.5</span><span>) </span><span style=color:#db784d>/ </span><span style=color:#95cc5e>float</span><span>(dir_count));
</span><span style=color:#95cc5e>vec2</span><span> dir    </span><span style=color:#db784d>= </span><span style=color:#95cc5e>vec2</span><span>(</span><span style=color:#95cc5e>cos</span><span>(angle), </span><span style=color:#95cc5e>sin</span><span>(angle));
</span></code></pre><blockquote><p>The <em>code snippet</em> above shows how we can derive an interval direction from its index within its probe.</blockquote><div class=img><img alt="Figure I: Cascade in texture memory." title="Figure I: Cascade in texture memory." src=https://m4xc.dev/img/articles/fundamental-rc/cascade-memory.png width=360px><i>Figure I: Cascade in texture memory.</i></div><p>Now, of course we're not going to store <span class=highlight>each probe</span> in its own texture.<br> Instead, let's store <span class=highlight>each cascade</span> in a texture, packing the probes together as shown in <em>Figure I</em>.<blockquote><p>There's also an alternative superior data layout, called <strong>direction first</strong>.<br> Where you store all intervals with the same direction together in blocks, which improves data locality during merging.</blockquote><p>This is where we see why decreasing the probe count by <strong>2x</strong> on <span class=highlight>each axis</span> is nice.<br> It works out <em>really well</em> when using this kind of packing.<p>If we decrease the angle between intervals by <strong>2x</strong> each cascade, each subsequent cascade will have <span class=highlight>half the intervals</span> of the previous.<br> Because the probe count is decreasing by <strong>2x</strong> along 2 axes, making it decrease by <strong>4x</strong>, while the interval count only increases by <strong>2x</strong>.<blockquote><p>Meaning our total interval count will aproach <strong>2x</strong> the interval count of the first cascade as we add more cascades.</blockquote><p>If instead, we decrease the angle between intervals by <strong>4x</strong> each cascade, each cascade will have <span class=highlight>equal the intervals</span>.<blockquote><p>Meaning our total interval count will grow linearly with cascade count.</blockquote><p>I <span class=highlight>recommend</span> using the <strong>4x</strong> branching method where interval count remains equal, it is <span class=highlight>simpler</span> to work with in practice.<h3 id=cascade-gathering>Cascade Gathering</h3><p>To gather the <span class=highlight>radiance</span> for each cascade we simply loop over each texel in its memory texture.<br> For each of those texels we <em>calculate the direction</em> and cast our interval into the scene.<p>First, let's find out what our coordinate is within the probe we're apart of:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Get the local texel coordinate in the local probe */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>ivec2</span><span> dir_coord </span><span style=color:#db784d>=</span><span> texel_coord </span><span style=color:#db784d>%</span><span> probe_size;
</span></code></pre><p>Second, we can convert this coordinate to a <span class=highlight>direction index</span>:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Convert our local texel coordinate to a direction index */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>int</span><span> dir_index </span><span style=color:#db784d>=</span><span> dir_coord.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>+</span><span> dir_coord.</span><span style=color:#f8bb39>y </span><span style=color:#db784d>*</span><span> probe_size.</span><span style=color:#f8bb39>x</span><span>;
</span></code></pre><p>Third, using that direction index we can obtain the direction vector: <em>(like I showed earlier)</em><pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#db784d>const </span><span style=color:#95cc5e>int</span><span> dir_count </span><span style=color:#db784d>=</span><span> probe_size.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>*</span><span> probe_size.</span><span style=color:#f8bb39>y</span><span>;
</span><span>
</span><span style=color:#7a7267>/* Compute interval direction from direction index */
</span><span style=color:#95cc5e>float</span><span> angle </span><span style=color:#db784d>= </span><span style=color:#eaae2e>2.0 </span><span style=color:#db784d>*</span><span> PI </span><span style=color:#db784d>* </span><span>((</span><span style=color:#95cc5e>float</span><span>(dir_index) </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>0.5</span><span>) </span><span style=color:#db784d>/ </span><span style=color:#95cc5e>float</span><span>(dir_count));
</span><span style=color:#95cc5e>vec2</span><span> dir    </span><span style=color:#db784d>= </span><span style=color:#95cc5e>vec2</span><span>(</span><span style=color:#95cc5e>cos</span><span>(angle), </span><span style=color:#95cc5e>sin</span><span>(angle));
</span></code></pre><p>Now we have to <span class=highlight>cast the interval</span>, let's not forget intervals have a start and end time:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#95cc5e>vec2</span><span> interval_start </span><span style=color:#db784d>=</span><span> probe_pos </span><span style=color:#db784d>+</span><span> dir </span><span style=color:#db784d>*</span><span> start_time;
</span><span style=color:#95cc5e>vec2</span><span> interval_end   </span><span style=color:#db784d>=</span><span> probe_pos </span><span style=color:#db784d>+</span><span> dir </span><span style=color:#db784d>*</span><span> end_time;
</span><span style=color:#95cc5e>vec3</span><span> radiance       </span><span style=color:#db784d>= </span><span style=color:#207241>cast_interval</span><span>(interval_start, interval_end);
</span></code></pre><p>It's important to note, the <code>cast_interval</code> function can use whatever <span class=highlight>ray casting method</span> you want.<br> As long as it returns the radiance information from the scene from the start to the end position.<p>The <span class=highlight>start & end time</span> of our intervals depends on which cascade we're evaluating, and what branching is used.<br> For <strong>4x</strong> branching (the branching I recommend) we can use this code to find the start & end times:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Get the scale factor for an interval in a given cascade */
</span><span style=color:#95cc5e>float </span><span style=color:#60a365>interval_scale</span><span>(</span><span style=color:#95cc5e>int </span><span style=color:#f8bb39;font-style:italic>cascade_index</span><span>) {
</span><span>    </span><span style=color:#db784d>if </span><span>(cascade_index </span><span style=color:#db784d><= </span><span style=color:#eaae2e>0</span><span>) </span><span style=color:#db784d>return </span><span style=color:#eaae2e>0.0</span><span>;
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Scale interval by 4x each cascade */
</span><span>    </span><span style=color:#db784d>return </span><span style=color:#95cc5e>float</span><span>(</span><span style=color:#eaae2e>1 </span><span style=color:#db784d><< </span><span>(</span><span style=color:#eaae2e>2 </span><span style=color:#db784d>*</span><span> cascade_index));
</span><span>}
</span><span>
</span><span style=color:#7a7267>/* Get the start & end time of an interval for a given cascade */
</span><span style=color:#95cc5e>vec2 </span><span style=color:#60a365>interval_range</span><span>(</span><span style=color:#95cc5e>int </span><span style=color:#f8bb39;font-style:italic>cascade_index</span><span>, </span><span style=color:#95cc5e>float </span><span style=color:#f8bb39;font-style:italic>base_length</span><span>) {
</span><span>    </span><span style=color:#db784d>return</span><span> base_length </span><span style=color:#db784d>* </span><span style=color:#95cc5e>vec2</span><span>(</span><span style=color:#207241>interval_scale</span><span>(i), </span><span style=color:#207241>interval_scale</span><span>(i </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>1</span><span>));
</span><span>}
</span></code></pre><blockquote><p>The <code>base_length</code> above is the length you want intervals in cascade0 to have.</blockquote><hr><h2 id=merging>Merging</h2><p>Now we have our <span class=highlight>radiance field</span> stored as cascades in textures. <em>Awesome!</em><br> The next step is to <span class=highlight>extract the data</span> we want from this data structure <em>(the cascade hierarchy)</em>.<p>We're going to extract specifically the <span class=highlight>diffuse irradiance</span> of the scene. <em>(also called fluence in 2D)</em><br> This basically means <em>summing up</em> the radiance coming from <span class=highlight>all directions</span> for a specific point.<h3 id=merging-intervals>Merging Intervals</h3><p>We've talked about basically splitting our rays into seperate intervals, probes => rings.<br> So how can we connect those seperate intervals back again, to make up a ray?<div class=video><video autoplay class=video loop muted playsinline preload=none style=width:360px><source src=https://m4xc.dev/anim/articles/fundamental-rc/interval-merge-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure J: Green interval should occlude red interval.</i></div><p>In <em>Figure J</em>, we can see that intervals earlier in the chain can <span class=highlight>occlude</span> intervals further down the chain.<br> To properly resolve this relation, we usually use a <span class=highlight>ray visibility term</span> which is stored in the alpha channel.<br> This term is set during the <span class=highlight>initial gathering</span>, it is <code>1.0</code> if the interval hit nothing, and <code>0.0</code> if it did.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Merge 2 connected intervals with respect to their visibility term */
</span><span style=color:#95cc5e>vec4 </span><span style=color:#60a365>merge_intervals</span><span>(</span><span style=color:#95cc5e>vec4 </span><span style=color:#f8bb39;font-style:italic>near</span><span>, </span><span style=color:#95cc5e>vec4 </span><span style=color:#f8bb39;font-style:italic>far</span><span>) {
</span><span>    </span><span style=color:#7a7267>/* Far radiance can get occluded by near visibility term */
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>vec3</span><span> radiance </span><span style=color:#db784d>=</span><span> near.</span><span style=color:#f8bb39>rgb </span><span style=color:#db784d>+ </span><span>(far.</span><span style=color:#f8bb39>rgb </span><span style=color:#db784d>*</span><span> near.</span><span style=color:#f8bb39>a</span><span>);
</span><span>
</span><span>    </span><span style=color:#db784d>return </span><span style=color:#95cc5e>vec4</span><span>(radiance, near.</span><span style=color:#f8bb39>a </span><span style=color:#db784d>*</span><span> far.</span><span style=color:#f8bb39>a</span><span>);
</span><span>}
</span></code></pre><p>The <em>code snippet</em> above shows how we can implement interval merging in code.<br> As we can see, <span class=highlight>radiance</span> from the <strong>far</strong> interval can be occluded by the visibility term of the <strong>near</strong> interval.<blockquote><p>We also merge the visibility terms, by multiplying them a hit will also be carried downwards. <em>(1.0 * 0.0 = 0.0)</em></blockquote><h3 id=merging-cones>Merging Cones</h3><p>It would be <span class=highlight>really expensive</span> if we had to merge through each cascade for each possible direction.<br> So instead, let's merge each cascade into the one below it, from the <span class=highlight>top down</span>.<div class=img><img alt="Figure K: Cone made out of intervals." title="Figure K: Cone made out of intervals." src=https://m4xc.dev/img/articles/fundamental-rc/interval-cone.png width=360px><i>Figure K: Cone made out of intervals.</i></div><p>Because we're trying to extract <span class=highlight>diffuse lighting</span>, directional resolution isn't very important.<br> So it's completely fine to <em>squash</em> the entire scene radiance into <strong>cascade0</strong> <em>(which has the lowest angular resolution)</em><p>Because we have a <span class=highlight>branch factor</span>, e.g. <strong>4x</strong>, each cascade we will merge <strong>4</strong> intervals down into <strong>1</strong> interval.<br> Doing so for all cascades <span class=highlight>recursively</span> captures the radiance from a cone, as shown in <em>Figure K</em>.<p>This is perfect for capturing our <span class=highlight>low angular resolution</span> diffuse lighting!<h3 id=merging-spatially>Merging Spatially</h3><p>Not only our angular resolution changes between cascades, we also know our spatial resolution changes.<br> If we always merge with the <span class=highlight>nearest</span> probe from the next cascade, we will get an obvious <span class=highlight>grid pattern</span>.<blockquote><p>The "next cascade" is the cascade above the current one, it has lower spatial & higher angular resolution.</blockquote><div class=img><img alt="Figure L: Merging with nearest probe only." title="Figure L: Merging with nearest probe only." src=https://m4xc.dev/img/articles/fundamental-rc/nearest-interp.png width=360px><i>Figure L: Merging with nearest probe only.</i></div><p>In <em>Figure L</em>, we can clearly see this obvious grid pattern, which actually <span class=highlight>visualizes</span> the probes themselves.<br> It is a cool effect, but not exactly the smooth penumbrae we're looking for.<div class=img><img alt="Figure M: Merging with 4 bilinear probes." title="Figure M: Merging with 4 bilinear probes." src=https://m4xc.dev/img/articles/fundamental-rc/bilinear-probes.png width=360px><i>Figure M: Merging with 4 bilinear probes.</i></div><blockquote><p>Weights shown in <em>Figure M</em> are incorrect! They should always add up to <code>1.0</code>.</blockquote><p>Let's instead use <span class=highlight>bilinear interpolation</span> to merge with the nearest <strong>4</strong> probes from the next cascade.<br> We can see what this looks like in <em>Figure M</em>, <span class=highlight>bilinear probes</span> closer to the destination probe get higher weights.<p>I like to think of it as <span class=highlight>blurring</span> those blocky probes in <em>Figure L</em> with their neighbours.<blockquote><p>I tend to refer to the <strong>green</strong> probes as "bilinear probes" & the <strong>blue</strong> probe as "destination probe".</blockquote><div class=img><img alt="Figure N: Smooth penumbrae using bilinear interpolation." title="Figure N: Smooth penumbrae using bilinear interpolation." src=https://m4xc.dev/img/articles/fundamental-rc/bilinear-interp.png width=360px><i>Figure N: Smooth penumbrae using bilinear interpolation.</i></div><p>In <em>Figure N</em>, we can see the effect of <span class=highlight>spatially interpolating</span> the probes using bilinear interpolation.<br> The result is nice <span class=highlight>smooth penumbrae</span>, instead of the blocky ones we got with nearest interpolation.<h3 id=merging-algorithm>Merging Algorithm</h3><p>Let's put our <span class=highlight>angular & spatial</span> merging together to finally obtain our diffuse lighting.<blockquote><p>Remember, we merge top down, starting with the lowest spatial resolution going down to the highest spatial resolution.</blockquote><p>Starting from the top, the <span class=highlight>first cascade</span> doesn't have a cascade to merge with.<br> We can either skip it, or we can merge with a <span class=highlight>skybox</span> for example.<p>For every other cascade we will <span class=highlight>merge</span> with the one above it, we can write this as: $ N_{i+1} \to N_{i} $<br> From now on I'll be referring to them as <strong>N+1</strong> and <strong>N</strong> for simplicity.<p>The first step is finding our <strong>4</strong> <span class=highlight>bilinear probes</span> from <strong>N+1</strong>, and their respective weights.<br> To find the <strong>4</strong> bilinear probes we get the <em>top-left</em> bilinear probe index, and then simply iterate over a <strong>2x2</strong> from that <code>base_index</code>.<br> And we'll use the fractional part of that <code>base_index</code> to derive our <span class=highlight>bilinear weights</span>:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Sub-texel offset to bilinear interpolation weights */
</span><span style=color:#95cc5e>vec4 </span><span style=color:#60a365>bilinear_weights</span><span>(</span><span style=color:#95cc5e>vec2 </span><span style=color:#f8bb39;font-style:italic>ratio</span><span>) {
</span><span>    </span><span style=color:#db784d>return </span><span style=color:#95cc5e>vec4</span><span>(
</span><span>        (</span><span style=color:#eaae2e>1.0 </span><span style=color:#db784d>-</span><span> ratio.</span><span style=color:#f8bb39>x</span><span>) </span><span style=color:#db784d>* </span><span>(</span><span style=color:#eaae2e>1.0 </span><span style=color:#db784d>-</span><span> ratio.</span><span style=color:#f8bb39>y</span><span>),
</span><span>        ratio.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>* </span><span>(</span><span style=color:#eaae2e>1.0 </span><span style=color:#db784d>-</span><span> ratio.</span><span style=color:#f8bb39>y</span><span>),
</span><span>        (</span><span style=color:#eaae2e>1.0 </span><span style=color:#db784d>-</span><span> ratio.</span><span style=color:#f8bb39>x</span><span>) </span><span style=color:#db784d>*</span><span> ratio.</span><span style=color:#f8bb39>y</span><span>,
</span><span>        ratio.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>*</span><span> ratio.</span><span style=color:#f8bb39>y
</span><span>    );
</span><span>}
</span><span>
</span><span style=color:#95cc5e>void </span><span style=color:#60a365>bilinear_samples</span><span>(</span><span style=color:#95cc5e>vec2 </span><span style=color:#f8bb39;font-style:italic>dest_center</span><span>, </span><span style=color:#95cc5e>vec2 </span><span style=color:#f8bb39;font-style:italic>bilinear_size</span><span>, </span><span style=color:#db784d>out </span><span style=color:#95cc5e>vec4 </span><span style=color:#f8bb39;font-style:italic>weights</span><span>, </span><span style=color:#db784d>out </span><span style=color:#95cc5e>ivec2 </span><span style=color:#f8bb39;font-style:italic>base_index</span><span>) {
</span><span>    </span><span style=color:#7a7267>/* Coordinate of the top-left bilinear probe when floored */
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>vec2</span><span> base_coord </span><span style=color:#db784d>= </span><span>(dest_center </span><span style=color:#db784d>/</span><span> bilinear_size) </span><span style=color:#db784d>- </span><span style=color:#95cc5e>vec2</span><span>(</span><span style=color:#eaae2e>0.5</span><span>, </span><span style=color:#eaae2e>0.5</span><span>);
</span><span>
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>vec2</span><span> ratio </span><span style=color:#db784d>= </span><span style=color:#95cc5e>fract</span><span>(base_coord);  </span><span style=color:#7a7267>/* Sub-bilinear probe position */
</span><span>    weights </span><span style=color:#db784d>= </span><span style=color:#207241>bilinear_weights</span><span>(ratio);
</span><span>    base_index </span><span style=color:#db784d>= </span><span style=color:#95cc5e>ivec2</span><span>(</span><span style=color:#95cc5e>floor</span><span>(base_coord)); </span><span style=color:#7a7267>/* Top-left bilinear probe coordinate */
</span><span>}
</span></code></pre><p>As inputs our <code>bilinear_samples</code> takes the following parameters:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#95cc5e>vec2</span><span> dest_center </span><span style=color:#db784d>=</span><span> ...; </span><span style=color:#7a7267>/* Center position of destination probe in pixels */
</span><span style=color:#95cc5e>vec2</span><span> bilinear_size </span><span style=color:#db784d>=</span><span> ...; </span><span style=color:#7a7267>/* Size of bilinear probe in pixels */
</span></code></pre><p>Now we will have 2 <span class=highlight>nested loops</span>:<br> For each of the <strong>4</strong> bilinear probes, we will merge with <strong>4</strong> of their intervals.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* For each extra N+1 interval */
</span><span style=color:#db784d>for </span><span>(</span><span style=color:#95cc5e>int</span><span> d </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>; d </span><span style=color:#db784d>< </span><span style=color:#eaae2e>4</span><span>; d</span><span style=color:#db784d>++</span><span>) {
</span><span>    </span><span style=color:#7a7267>/* For each N+1 bilinear probe */
</span><span>    </span><span style=color:#db784d>for </span><span>(</span><span style=color:#95cc5e>int</span><span> b </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>; b </span><span style=color:#db784d>< </span><span style=color:#eaae2e>4</span><span>; b</span><span style=color:#db784d>++</span><span>) {
</span><span>        </span><span style=color:#db784d>const </span><span style=color:#95cc5e>ivec2</span><span> base_offset </span><span style=color:#db784d>= </span><span style=color:#207241>bilinear_offset</span><span>(b);
</span><span>
</span><span>        </span><span style=color:#7a7267>/* ... */
</span><span>    }
</span><span>}
</span></code></pre><div class=img><img alt="Figure O: Merging for 1 interval (in blue)." title="Figure O: Merging for 1 interval (in blue)." src=https://m4xc.dev/img/articles/fundamental-rc/full-merge.png width=360px><i>Figure O: Merging for 1 interval (in blue).</i></div><p>Looking at <em>Figure O</em>, we get a visual of what those <span class=highlight>nested loops</span> are for.<br> Looping over the <strong>4</strong> nearest probes from <strong>N+1</strong> and <em>(in this graphic 2)</em> intervals.<br> <em>Figure O</em> is drawn with a <span class=highlight>branch factor</span> of <strong>2x</strong> instead of our <strong>4x</strong> otherwise it can get quite busy with all the intervals.<blockquote><p>The <strong>green</strong> intervals in <em>Figure O</em> are colored based on their bilinear <strong>weights</strong>, brighter means a higher weight.</blockquote><p>You may have noticed the <code>bilinear_offset</code> function in the <span class=highlight>inner loop</span>.<br> It simply converts our <strong>1D</strong> index into a coordinate in the <strong>2x2</strong> bilinear square:<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Convert index 0..4 to a 2d index in a 2x2 square */
</span><span style=color:#95cc5e>ivec2 </span><span style=color:#60a365>bilinear_offset</span><span>(</span><span style=color:#95cc5e>int </span><span style=color:#f8bb39;font-style:italic>offset_index</span><span>) {
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>ivec2</span><span> offsets[</span><span style=color:#eaae2e>4</span><span>] </span><span style=color:#db784d>= </span><span>{ </span><span style=color:#95cc5e>ivec2</span><span>(</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>), </span><span style=color:#95cc5e>ivec2</span><span>(</span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>0</span><span>), </span><span style=color:#95cc5e>ivec2</span><span>(</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>1</span><span>), </span><span style=color:#95cc5e>ivec2</span><span>(</span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>1</span><span>) };
</span><span>    </span><span style=color:#db784d>return</span><span> offsets[offset_index];
</span><span>}
</span></code></pre><p>We can add our <code>base_offset</code> to the <code>base_index</code> we got <span class=highlight>earlier</span> to get the <strong>2D</strong> index of the bilinear probe.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Get the index of the bilinear probe to merge with */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>ivec2</span><span> bilinear_index </span><span style=color:#db784d>=</span><span> base_index </span><span style=color:#db784d>+</span><span> base_offset;
</span></code></pre><p>Now it is relatively trivial to use our <code>dir_index</code> we learned how to get earlier.<br> To get a directional <code>base_index</code> and add <code>d</code> to it.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Get the directional base index */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>int</span><span> base_dir_index </span><span style=color:#db784d>=</span><span> dir_index </span><span style=color:#db784d>* </span><span style=color:#eaae2e>4</span><span>;
</span><span>
</span><span style=color:#7a7267>/* Get the directional index we want to merge with */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>int</span><span> bilinear_dir_index </span><span style=color:#db784d>=</span><span> base_dir_index </span><span style=color:#db784d>+</span><span> d;
</span></code></pre><p>Then finally we can combine the <code>bilinear_dir_index</code> & <code>bilinear_index</code> to get the <span class=highlight>texel</span> coordinate in cascade <strong>N+1</strong> to merge with.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* Convert the directional index to a local texel coordinate */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>ivec2</span><span> bilinear_dir_coord </span><span style=color:#db784d>= </span><span style=color:#95cc5e>ivec2</span><span>(
</span><span>    bilinear_dir_index </span><span style=color:#db784d>%</span><span> bilinear_size.</span><span style=color:#f8bb39>x</span><span>,
</span><span>    bilinear_dir_index </span><span style=color:#db784d>/</span><span> bilinear_size.</span><span style=color:#f8bb39>y
</span><span>);
</span><span>
</span><span style=color:#7a7267>/* Get the texel coordinate to merge with in cascade N+1 */
</span><span style=color:#db784d>const </span><span style=color:#95cc5e>ivec2</span><span> bilinear_texel </span><span style=color:#db784d>=</span><span> bilinear_index </span><span style=color:#db784d>*</span><span> bilinear_size </span><span style=color:#db784d>+</span><span> bilinear_dir_coord;
</span></code></pre><p>Merging we do using the <code>merge_intervals</code> function from <span class=highlight>ealier</span> in the article.<pre class=language-glsl data-lang=glsl style=color:#e8d4c0;background-color:#191919><code class=language-glsl data-lang=glsl><span style=color:#7a7267>/* For each extra N+1 interval */
</span><span style=color:#95cc5e>vec4</span><span> merged </span><span style=color:#db784d>= </span><span style=color:#95cc5e>vec4</span><span>(</span><span style=color:#eaae2e>0.0</span><span>);
</span><span style=color:#db784d>for </span><span>(</span><span style=color:#95cc5e>int</span><span> d </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>; d </span><span style=color:#db784d>< </span><span style=color:#eaae2e>4</span><span>; d</span><span style=color:#db784d>++</span><span>) {
</span><span>    </span><span style=color:#7a7267>/* For each N+1 bilinear probe */
</span><span>    </span><span style=color:#95cc5e>vec4</span><span> radiance </span><span style=color:#db784d>= </span><span style=color:#95cc5e>vec4</span><span>(</span><span style=color:#eaae2e>0.0</span><span>);
</span><span>    </span><span style=color:#db784d>for </span><span>(</span><span style=color:#95cc5e>int</span><span> b </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>; b </span><span style=color:#db784d>< </span><span style=color:#eaae2e>4</span><span>; b</span><span style=color:#db784d>++</span><span>) {
</span><span>        </span><span style=color:#7a7267>/* ... */
</span><span>
</span><span>        </span><span style=color:#7a7267>/* Fetch the bilinear interval from the cascade N+1 texture */
</span><span>        </span><span style=color:#db784d>const </span><span style=color:#95cc5e>vec4</span><span> bilinear_interval </span><span style=color:#db784d>= </span><span style=color:#207241>textureFetch</span><span>(bilinear_texel);
</span><span>
</span><span>        </span><span style=color:#7a7267>/* Merge our destination interval with the bilinear interval */
</span><span>        radiance </span><span style=color:#db784d>+= </span><span style=color:#207241>merge_intervals</span><span>(destination_interval, bilinear_interval) </span><span style=color:#db784d>*</span><span> weights[b];
</span><span>    }
</span><span>
</span><span>    merged </span><span style=color:#db784d>+=</span><span> radiance </span><span style=color:#db784d>/ </span><span style=color:#eaae2e>4.0</span><span>;
</span><span>}
</span></code></pre><p><span class=highlight>That's all</span>! We've now merged all the cascades down into <strong>cascade0</strong>.<h3 id=final-pass>Final Pass</h3><p>I did say <em>"that's all"</em>, I know, I know, but there's <span class=highlight>one more step</span>,<br> which is to <span class=highlight>integrate</span> the irradiance stored in the now merged <strong>cascade0</strong>.<p>Luckily this is <em>relatively trivial</em>, we already have most of the code we need.<br> We simply <span class=highlight>bilinearly interpolate</span> between the <strong>4</strong> nearest <strong>cascade0</strong> probes for each pixel.<br> And sum up the radiance from all intervals. <em>(cones)</em><div class=img><img alt="Figure P: Final result! (Credit: Fad's Shadertoy)" title="Figure P: Final result! (Credit: Fad's Shadertoy)" src=https://m4xc.dev/img/articles/fundamental-rc/final-result.png width=540px><i>Figure P: Final result! (Credit: Fad's Shadertoy)</i></div><blockquote><p>Image credit: <a href=https://www.shadertoy.com/view/mtlBzX>Fad's Shadertoy</a>.</blockquote><p>If we did everything correctly, we should end up with a <span class=highlight>beautiful</span> result like in <em>Figure P</em>.<p>For those who made it all the way till the end, <span class=highlight>thank you</span> for reading my article!<br> I hope it sheds some light on how & why <span class=highlight>Radiance Cascades</span> work.<br> It took me a while to properly understand it, and a lot of trial & error to get it working :)<hr><h2 id=amazing-resources>Amazing Resources</h2><p>There's quite a few resources already out there related to RC. <em>(which also helped me)</em><br> I will list a few of them here, so you can get explanations from <span class=highlight>different perspectives</span>:<ul><li>Alexander Sannikov's <a href=https://github.com/Raikiri/RadianceCascadesPaper>paper</a> on Radiance Cascades.<li>XorDev & Yaazarai's articles, <a href=https://mini.gmshaders.com/p/radiance-cascades>part 1</a> & <a href=https://mini.gmshaders.com/p/radiance-cascades2>part 2</a>.<li>SimonDev's video <a href=https://youtu.be/3so7xdZHKxw>https://youtu.be/3so7xdZHKxw</a>.<li>Christopher M. J. Osborne's <a href=https://arxiv.org/abs/2408.14425>paper</a> diving deeper into the bilinear fix.<li>Jason's blog post <a href=https://jason.today/rc>https://jason.today/rc</a>.<li>Fad's <a href=https://www.shadertoy.com/view/mtlBzX>Shadertoy</a> implementation.</ul><blockquote><p>Also check out our <a href=https://discord.gg/WQ4hCHhUuU>Discord community</a> there's a lot of awesome people there that might be able to help you out!</blockquote></div><footer class=site-footer><p class=end-msg id=end-msg>---- Thanks for reading! ----</p><i>© 2020-<span id=year>2024</span> Max &LTmxcop>, All rights reserved</i></footer><script>const end_msg=document.getElementById(`end-msg`);const msg_idx=Math.floor(Math.random()*3);const msg_arr=[`Thank you for reading!`,`Hope you enjoyed the content!`,`Have a great day!`];end_msg.innerText=`---- `+ msg_arr[msg_idx]+ ` ----`;const year_el=document.getElementById(`year`);year_el.innerText=new Date().getFullYear()</script></main>