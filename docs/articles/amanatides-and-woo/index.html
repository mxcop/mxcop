<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><title>MΛX - Amanatides and Woo's fast Voxel Traversal</title><meta content="© 2020-2024 Max <mxcop>, All rights reserved" name=copyright><meta content="A look at the inner workings of the famous fast voxel traversal algorithm." name=description><link href=https://mxcop.github.io/mxcop/general.css rel=stylesheet><meta content="Max <mxcop>" name=author><meta content="graphics, voxel traversal" name=keywords><link href=https://mxcop.github.io/mxcop/sections/post.css rel=stylesheet><link href=https://mxcop.github.io/mxcop/katex/katex.min.css rel=stylesheet><script src=https://mxcop.github.io/mxcop/katex/katex.min.js></script><script src=https://mxcop.github.io/mxcop/katex/render.min.js></script><script src=https://mxcop.github.io/mxcop/katex/hook.js></script><body><div class=gradient-bg></div><script>if(localStorage.getItem(`theme`)===`dark`){document.body.classList.add(`dark`)}else if(localStorage.getItem(`theme`)===`light`){document.body.classList.remove(`dark`)}else if(window.matchMedia(`(prefers-color-scheme: dark)`).matches){document.body.classList.add(`dark`)};const toggleDark=()=>{let a=`dark`;document.body.classList.toggle(a);localStorage.setItem(`theme`,document.body.classList.contains(a)?a:`light`)}</script><div class=navbar><div class=bar><h3 class=title>MΛX</h3><nav><a href=https://mxcop.github.io/mxcop/>Home</a><a href=https://mxcop.github.io/mxcop/articles/>Articles</a></nav><div class=theme-toggle><button class=ico-btn onclick=toggleDark()><i class="ico theme"></i></button></div></div></div><main><div class=post><h1 class=post-title>Amanatides and Woo's fast Voxel Traversal</h1><span class=post-sub> <i title="Originally posted on 2024-04-20.">2024-08-17</i> • 1240 words • 7 min • Max &LTmxcop> </span><h2 id=introduction>Introduction</h2><p>In this article we will dive deep into <a href=https://www.researchgate.net/publication/2611491_A_Fast_Voxel_Traversal_Algorithm_for_Ray_Tracing>Amanatides and Woo's fast voxel traversal algorithm</a>.<br> Designed for, however not limited to, <span class=highlight>ray tracing</span> voxel grids.<blockquote><p>Most visual examples in this article will be 2D for convenience however, the concepts are the same for 3D.<br> All code snippets provided will be using C++ 20 and will be for 3D voxel traversal.</blockquote><p>You may wonder <em>"What can voxel ray tracing do?"</em>.<br> Here's two screenshots taken from my own <code>CPU</code> voxel ray tracer:<div class=img2x1><div class=img><img alt="Ray traced voxels with lighting." title="Ray traced voxels with lighting." src=https://mxcop.github.io/mxcop/img/articles/amanatides-and-woo/lit-voxels.png width=360px><i>Ray traced voxels with lighting.</i></div><div class=img><img alt="Ray traced voxel terrain." title="Ray traced voxel terrain." src=https://mxcop.github.io/mxcop/img/articles/amanatides-and-woo/voxel-terrain.png width=360px><i>Ray traced voxel terrain.</i></div></div><p>Together we're going to find out how and why this algorithm works.<br> <em>So, let's dive in!</em><hr><h2 id=prerequisites>Prerequisites</h2><p>To get started tracing anything, we need some <span class=highlight>data to traverse</span>!<br> Let's setup a little <code>VoxelTracer</code> class together:<pre class=language-cpp data-lang=cpp style=color:#e8d4c0;background-color:#191919><code class=language-cpp data-lang=cpp><span style=color:#db784d>constexpr </span><span style=color:#95cc5e>int</span><span> GRID_SIDE </span><span style=color:#db784d>= </span><span style=color:#eaae2e>32</span><span>;
</span><span>
</span><span style=color:#95cc5e>class </span><span style=color:#db784d>VoxelTracer </span><span>{
</span><span>    </span><span style=color:#7a7267>/* Grid voxel data. */
</span><span>    </span><span style=color:#95cc5e>unsigned int</span><span> grid[GRID_SIDE </span><span style=color:#db784d>*</span><span> GRID_SIDE </span><span style=color:#db784d>*</span><span> GRID_SIDE];
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Grid minimum and maximum point in world space. (x, y, z) */
</span><span>    vec3 grid_min, grid_max;
</span><span>
</span><span>  </span><span style=color:#db784d>public</span><span>:
</span><span>    </span><span style=color:#60a365>VoxelTracer</span><span>() { 
</span><span>        grid_min </span><span style=color:#db784d>= </span><span style=color:#207241>vec3</span><span>(</span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>, </span><span style=color:#eaae2e>0</span><span>);
</span><span>        grid_max </span><span style=color:#db784d>= </span><span style=color:#207241>vec3</span><span>(</span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>1</span><span>, </span><span style=color:#eaae2e>1</span><span>);
</span><span>
</span><span>        </span><span style=color:#7a7267>/* TODO: fill `grid` with data */
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#7a7267>/**
</span><span style=color:#7a7267>     * @brief Find the nearest intersection with the grid.
</span><span style=color:#7a7267>     * @param ro Ray origin
</span><span style=color:#7a7267>     * @param rd Ray direction (normalized)
</span><span style=color:#7a7267>     * @return `1e30f` if no intersection was found.
</span><span style=color:#7a7267>     */
</span><span>    </span><span style=color:#95cc5e>float </span><span style=color:#60a365>find_nearest</span><span>(</span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>ro</span><span>, </span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>rd</span><span>) </span><span style=color:#db784d>const</span><span>;
</span><span>};
</span></code></pre><p>What to fill <code>grid</code> with is up to you.<br> Each voxel in the grid is stored as a color <code>unsigned int</code>, RGBA.<blockquote><p>For some inspiration: you could fill it with a noise pattern, like <a href=https://en.wikipedia.org/wiki/Perlin_noise>Perlin noise</a>.</blockquote><p>Futhermore, before we start the traversal we need to <span class=highlight>intersect</span> our ray with the <span class=highlight>grid bounding box</span>.<br> If our ray <strong>doesn't</strong> intersect the grid then we don't need to traverse it.<br> If our ray <strong>does</strong> intersect we will also get the time along the ray where it enters the grid called <code>entry_t</code>.<pre class=language-cpp data-lang=cpp style=color:#e8d4c0;background-color:#191919><code class=language-cpp data-lang=cpp><span style=color:#7a7267>/**
</span><span style=color:#7a7267> * @brief Ray vs AABB intersection test. (can be optimized further)
</span><span style=color:#7a7267> * @param ro Ray origin
</span><span style=color:#7a7267> * @param rd Ray direction (normalized)
</span><span style=color:#7a7267> * @return Ray entry time, `1e30f` if no intersection was found.
</span><span style=color:#7a7267> */
</span><span style=color:#95cc5e>float </span><span style=color:#60a365>ray_aabb</span><span>(</span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>min</span><span>, </span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>max</span><span>, </span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>ro</span><span>, </span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>rd</span><span>) {
</span><span>    </span><span style=color:#95cc5e>float</span><span> tmin </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>, tmax </span><span style=color:#db784d>= </span><span style=color:#eaae2e>1e30</span><span style=color:#95cc5e>f</span><span>;
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Loop will be unrolled */
</span><span>    </span><span style=color:#db784d>for </span><span>(</span><span style=color:#95cc5e>int</span><span> axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>; axis </span><span style=color:#db784d>< </span><span style=color:#eaae2e>3</span><span>; </span><span style=color:#db784d>++</span><span>axis) {
</span><span>        </span><span style=color:#db784d>const </span><span style=color:#95cc5e>float</span><span> t1 </span><span style=color:#db784d>= </span><span>(min[axis] </span><span style=color:#db784d>-</span><span> ro[axis]) </span><span style=color:#db784d>/</span><span> rd[axis];
</span><span>        </span><span style=color:#db784d>const </span><span style=color:#95cc5e>float</span><span> t2 </span><span style=color:#db784d>= </span><span>(max[axis] </span><span style=color:#db784d>-</span><span> ro[axis]) </span><span style=color:#db784d>/</span><span> rd[axis];
</span><span>
</span><span>        </span><span style=color:#db784d>const </span><span style=color:#95cc5e>float</span><span> dmin </span><span style=color:#db784d>= </span><span style=color:#207241>min</span><span>(t1, t2);
</span><span>        </span><span style=color:#db784d>const </span><span style=color:#95cc5e>float</span><span> dmax </span><span style=color:#db784d>= </span><span style=color:#207241>max</span><span>(t1, t2);
</span><span>
</span><span>        tmin </span><span style=color:#db784d>= </span><span style=color:#207241>max</span><span>(dmin, tmin);
</span><span>        tmax </span><span style=color:#db784d>= </span><span style=color:#207241>min</span><span>(dmax, tmax);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#db784d>if </span><span>(tmax </span><span style=color:#db784d>>=</span><span> tmin) </span><span style=color:#db784d>return</span><span> tmin;
</span><span>    </span><span style=color:#db784d>return </span><span style=color:#eaae2e>1e30</span><span style=color:#95cc5e>f</span><span>; </span><span style=color:#7a7267>/* miss */
</span><span>}
</span></code></pre><p><sup>Snippet A.</sup><p><em>Snippet A</em> shows a basic <span class=highlight>ray vs aabb</span> intersection test you can use.<br> It is not an optimal one, nevertheless it will get the job done for now.<p>We can now put this intersection test at the top of our <code>find_nearest</code> function.<br> And for now, we can just return <code>entry_t</code> if there was a hit.<pre class=language-cpp data-lang=cpp style=color:#e8d4c0;background-color:#191919><code class=language-cpp data-lang=cpp><span style=color:#95cc5e>float </span><span>VoxelTracer::</span><span style=color:#60a365>find_nearest</span><span>(</span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>ro</span><span>, </span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>rd</span><span>) </span><span style=color:#db784d>const </span><span>{
</span><span>    </span><span style=color:#7a7267>/* Find the ray entry point */ 
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>float</span><span> entry_t </span><span style=color:#db784d>= </span><span style=color:#207241>ray_aabb</span><span>(grid_min, grid_max, ro, rd);
</span><span>
</span><span>    </span><span style=color:#db784d>if </span><span>(entry_t </span><span style=color:#db784d>== </span><span style=color:#eaae2e>1e30</span><span style=color:#95cc5e>f</span><span>) </span><span style=color:#db784d>return </span><span style=color:#eaae2e>1e30</span><span style=color:#95cc5e>f</span><span>; </span><span style=color:#7a7267>/* miss */
</span><span>
</span><span>    </span><span style=color:#7a7267>/* TODO: voxel traversal */
</span><span>
</span><span>    </span><span style=color:#db784d>return</span><span> entry_t; </span><span style=color:#7a7267>/* hit */
</span><span>}
</span></code></pre><p>If we shoot a ray for each pixel on screen, and turn the output of <code>find_nearest</code> into a grayscale color.<br> We should get something that looks like this:<div class=img><img alt="Depth output of our ray / AABB intersection test." title="Depth output of our ray / AABB intersection test." src=https://mxcop.github.io/mxcop/img/articles/amanatides-and-woo/ray-vs-aabb-test.png width=520px><i>Depth output of our ray / AABB intersection test.</i></div><hr><h2 id=traversal-concept>Traversal Concept</h2><p>The concept of <span class=highlight>Amanatides and Woo's</span> algorithm is simple:<br> We find at what time along the ray each axis crosses its next cell boundary.<br> The maximum time until we cross the next axis cell boundary is often called <code>tmax</code>.<p>At any point in the grid our next step will be on the axis where <code>tmax</code> is the smallest.<br> That might sound confusing, to hopefully make it more clear, I made this graphic:<div class=video><video autoplay class=video loop muted preload=none style=width:360px><source src=https://mxcop.github.io/mxcop/anim/articles/amanatides-and-woo/walk-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure A: Amanatides and Woo in action</i></div><p>We can see that on the <span class=highlight>1st</span> step, <code>tmax.x</code> is the smallest, because the <code>x</code> axis will cross its cell boundary before the <code>y</code> axis.<br> Then on the <span class=highlight>2nd</span> step, <code>tmax.x</code> was updated and it is now larger than <code>tmax.y</code>, therefore the next step is on the <code>y</code> axis.<p>Now the question is <em>"How do we calculate <code>tmax</code>?"</em>.<br> That's what we're going to find out next.<hr><h2 id=traversal-setup>Traversal Setup</h2><p>Now that we have our <code>VoxelTracer</code>, and we understand the basic concept, we can start implementing the algorithm.<br> Let's start with 2 important variables which will <span class=highlight>remain constant</span> during traversal:<div class=img2x1><div class=img><img alt="Figure B: Step (direction signs)" title="Figure B: Step (direction signs)" src=https://mxcop.github.io/mxcop/img/articles/amanatides-and-woo/step.png width=360px><i>Figure B: Step (direction signs)</i></div><div class=img><img alt="Figure C: Delta (reciprocal direction)" title="Figure C: Delta (reciprocal direction)" src=https://mxcop.github.io/mxcop/img/articles/amanatides-and-woo/delta.png width=360px><i>Figure C: Delta (reciprocal direction)</i></div></div><p>The <span class=highlight>first variable</span> <code>step</code> will be used to move through the grid along the ray direction.<br> Computed for each axis, if the ray direction axis is <strong>positive</strong> it is <code>1</code> and <code>-1</code> if <strong>negative</strong>.<br> Here's what that would look like in C++:<pre class=language-cpp data-lang=cpp style=color:#e8d4c0;background-color:#191919><code class=language-cpp data-lang=cpp><span style=color:#7a7267>/** @brief Get the sign of a float (-1 or 1) */
</span><span style=color:#db784d>inline </span><span style=color:#95cc5e>int </span><span style=color:#60a365>getsign</span><span>(</span><span style=color:#db784d>const </span><span style=color:#95cc5e>float </span><span style=color:#f8bb39;font-style:italic>f</span><span>) { </span><span style=color:#db784d>return </span><span style=color:#eaae2e>1 </span><span style=color:#db784d>- </span><span>(</span><span style=color:#95cc5e>int</span><span>)(((</span><span style=color:#95cc5e>unsigned int</span><span style=color:#db784d>&</span><span>)f) </span><span style=color:#db784d>>> </span><span style=color:#eaae2e>31</span><span>) </span><span style=color:#db784d>* </span><span style=color:#eaae2e>2</span><span>; }
</span><span>
</span><span style=color:#7a7267>/** @brief Get the signs of a 3D vector (-1 or 1) */
</span><span style=color:#db784d>inline</span><span> vec3 </span><span style=color:#60a365>sign_of_dir</span><span>(</span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>v</span><span>) {
</span><span>    </span><span style=color:#db784d>return </span><span style=color:#207241>vec3</span><span>(</span><span style=color:#207241>getsign</span><span>(v.</span><span style=color:#f8bb39>x</span><span>), </span><span style=color:#207241>getsign</span><span>(v.</span><span style=color:#f8bb39>y</span><span>), </span><span style=color:#207241>getsign</span><span>(v.</span><span style=color:#f8bb39>z</span><span>));
</span><span>}
</span></code></pre><p>The <span class=highlight>second variable</span> we need is <code>delta</code>, it is used to update <code>tmax</code> during traversal.<br> Computed for each axis, it is the <strong>absolute</strong> of <code>1.0</code> divided by the ray direction axis, also referred to as the reciprocal.<p>Now there's just 2 more variables left, these variables will be updated <span class=highlight>every step</span> during traversal.<div class=img2x1><div class=video><video autoplay class=video loop muted preload=none style=width:360px><source src=https://mxcop.github.io/mxcop/anim/articles/amanatides-and-woo/entry-anim.mp4 type=video/mp4> Video tag is not supported.</video><i>Figure D: Finding entry cell by truncating</i></div><div class=img><img alt="Figure E: Time at next cell boundary (tmax)" title="Figure E: Time at next cell boundary (tmax)" src=https://mxcop.github.io/mxcop/img/articles/amanatides-and-woo/tmax.png width=360px><i>Figure E: Time at next cell boundary (tmax)</i></div></div><p>The <span class=highlight>third variable</span> is our <code>pos</code> within the grid, we need to initialize it to our entry point in the grid.<br> This is very easy to do, we simply make sure our entry point is in grid space <em>(1 unit = 1 grid cell)</em><br> And then we truncate the floating entry point to get our entry grid position as seen in <em>Figure D</em>.<blockquote><p>It's also important to <code>clamp</code> the <code>pos</code> within the grid just in case.</blockquote><p>Now for the <span class=highlight>last variable</span> we need the mysterious <code>tmax</code> which will let us correctly determine the next step.<br> To initialize it, we get the offset between the grid <code>pos</code> and the entry point,<br> add only the positive part of our <code>step</code>, and finally divide by the ray direction <code>rd</code>.<pre class=language-cpp data-lang=cpp style=color:#e8d4c0;background-color:#191919><code class=language-cpp data-lang=cpp><span style=color:#7a7267>/* Compute how many voxels occupy a unit in world space */
</span><span style=color:#db784d>const</span><span> vec3 voxels_per_unit </span><span style=color:#db784d>=</span><span> GRID_SIDE </span><span style=color:#db784d>/ </span><span>(grid_max </span><span style=color:#db784d>-</span><span> grid_min);
</span><span>
</span><span style=color:#7a7267>/* Get the floating grid entry position */
</span><span style=color:#7a7267>/* `0.0001f` is to slightly nudge the point inside the grid */
</span><span style=color:#db784d>const</span><span> vec3 entry_pos </span><span style=color:#db784d>= </span><span>((ro </span><span style=color:#db784d>+</span><span> rd </span><span style=color:#db784d>* </span><span>(entry_t </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>0.0001</span><span style=color:#95cc5e>f</span><span>)) </span><span style=color:#db784d>-</span><span> grid_min) </span><span style=color:#db784d>*</span><span> voxels_per_unit;
</span><span>
</span><span style=color:#7a7267>/* Initialize the time along the ray when each axis crosses its next cell boundary */
</span><span>vec3 tmax </span><span style=color:#db784d>= </span><span>(pos </span><span style=color:#db784d>-</span><span> entry_pos </span><span style=color:#db784d>+ </span><span style=color:#207241>max</span><span>(step, </span><span style=color:#eaae2e>0</span><span>)) </span><span style=color:#db784d>/</span><span> rd;
</span></code></pre><p>Adding only the positive part of our <code>step</code> is important because each grid cells origin lies in its top left.<br> So when our ray is moving in the positive direction, we need to adjust for that fact,<br> while in the negative direction it is already correct.<p>Dividing by the ray direction is done to transform our <code>tmax</code> into the <em>"ray direction space"</em>.<br> This is important because later we will be updating <code>tmax</code> using our <code>delta</code>.<p><strong>Finally!</strong> We have everything setup, and we're ready to start traversing!<hr><h2 id=traversal>Traversal</h2><p>Now that everything is already setup for us, we get to the easiest part, the <span class=highlight>actual traversal</span>.<br> As I mentioned in the <em>Concept</em> part of the article, we will simply step based on the smallest axis of <code>tmax</code>.<br> And after every step, we update our <code>pos</code> and <code>tmax</code>.<pre class=language-cpp data-lang=cpp style=color:#e8d4c0;background-color:#191919><code class=language-cpp data-lang=cpp><span style=color:#95cc5e>int</span><span> axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>;
</span><span style=color:#db784d>for </span><span>(</span><span style=color:#db784d>...</span><span>) {
</span><span>    </span><span style=color:#7a7267>/* Fetch the cell at our current position */
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>int</span><span> i </span><span style=color:#db784d>=</span><span> pos.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>*</span><span> GRID_SIDE </span><span style=color:#db784d>*</span><span> GRID_SIDE </span><span style=color:#db784d>+</span><span> pos.</span><span style=color:#f8bb39>y </span><span style=color:#db784d>*</span><span> GRID_SIDE </span><span style=color:#db784d>+</span><span> pos.</span><span style=color:#f8bb39>x</span><span>;
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>unsigned int</span><span> voxel </span><span style=color:#db784d>=</span><span> grid[i];
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Check if we hit a voxel which isn't 0 */
</span><span>    </span><span style=color:#db784d>if </span><span>(voxel) {
</span><span>        </span><span style=color:#db784d>if </span><span>(steps </span><span style=color:#db784d>== </span><span style=color:#eaae2e>0</span><span>) </span><span style=color:#db784d>return</span><span> entry_t;
</span><span>
</span><span>        </span><span style=color:#7a7267>/* Return the time of intersection! */
</span><span>        </span><span style=color:#db784d>return</span><span> entry_t </span><span style=color:#db784d>+ </span><span>(tmax[axis] </span><span style=color:#db784d>-</span><span> delta[axis]) </span><span style=color:#db784d>/</span><span> voxels_per_unit[axis];
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Step on the axis where `tmax` is the smallest */
</span><span>    </span><span style=color:#db784d>if </span><span>(tmax.</span><span style=color:#f8bb39>x </span><span style=color:#db784d><</span><span> tmax.</span><span style=color:#f8bb39>y</span><span>) {
</span><span>        </span><span style=color:#db784d>if </span><span>(tmax.</span><span style=color:#f8bb39>x </span><span style=color:#db784d><</span><span> tmax.</span><span style=color:#f8bb39>z</span><span>) {
</span><span>            pos.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>+=</span><span> step.</span><span style=color:#f8bb39>x</span><span>;
</span><span>            </span><span style=color:#db784d>if </span><span>(pos.</span><span style=color:#207241>x </span><span>< </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>||</span><span> pos.</span><span style=color:#f8bb39>x </span><span>></span><span style=color:#db784d>=</span><span> GRID_SIDE) </span><span style=color:#db784d>break</span><span>;
</span><span>            axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>;
</span><span>            tmax.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>+=</span><span> delta.</span><span style=color:#f8bb39>x</span><span>;
</span><span>        } </span><span style=color:#db784d>else </span><span>{
</span><span>            pos.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>+=</span><span> step.</span><span style=color:#f8bb39>z</span><span>;
</span><span>            </span><span style=color:#db784d>if </span><span>(pos.</span><span style=color:#207241>z </span><span>< </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>||</span><span> pos.</span><span style=color:#f8bb39>z </span><span>></span><span style=color:#db784d>=</span><span> GRID_SIDE) </span><span style=color:#db784d>break</span><span>;
</span><span>            axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>2</span><span>;
</span><span>            tmax.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>+=</span><span> delta.</span><span style=color:#f8bb39>z</span><span>;
</span><span>        }
</span><span>    } </span><span style=color:#db784d>else </span><span>{
</span><span>        </span><span style=color:#db784d>if </span><span>(tmax.</span><span style=color:#f8bb39>y </span><span style=color:#db784d><</span><span> tmax.</span><span style=color:#f8bb39>z</span><span>) {
</span><span>            pos.</span><span style=color:#f8bb39>y </span><span style=color:#db784d>+=</span><span> step.</span><span style=color:#f8bb39>y</span><span>;
</span><span>            </span><span style=color:#db784d>if </span><span>(pos.</span><span style=color:#207241>y </span><span>< </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>||</span><span> pos.</span><span style=color:#f8bb39>y </span><span>></span><span style=color:#db784d>=</span><span> GRID_SIDE) </span><span style=color:#db784d>break</span><span>;
</span><span>            axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>1</span><span>;
</span><span>            tmax.</span><span style=color:#f8bb39>y </span><span style=color:#db784d>+=</span><span> delta.</span><span style=color:#f8bb39>y</span><span>;
</span><span>        } </span><span style=color:#db784d>else </span><span>{
</span><span>            pos.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>+=</span><span> step.</span><span style=color:#f8bb39>z</span><span>;
</span><span>            </span><span style=color:#db784d>if </span><span>(pos.</span><span style=color:#207241>z </span><span>< </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>||</span><span> pos.</span><span style=color:#f8bb39>z </span><span>></span><span style=color:#db784d>=</span><span> GRID_SIDE) </span><span style=color:#db784d>break</span><span>;
</span><span>            axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>2</span><span>;
</span><span>            tmax.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>+=</span><span> delta.</span><span style=color:#f8bb39>z</span><span>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p><sup>Snippet B.</sup><p>In <em>Snippet B</em>, we also track <code>axis</code>, the previous axis we stepped on.<br> Because when we hit something, we want to return the <span class=highlight>time of intersection</span> with whatever we hit.<br> Which is the previous <code>tmax</code> along the previously stepped <code>axis</code>.<br> We can go back one <em>step</em> by subtracting <code>delta[axis]</code> from <code>tmax[axis]</code>:<pre class=language-cpp data-lang=cpp style=color:#e8d4c0;background-color:#191919><code class=language-cpp data-lang=cpp><span>entry_t </span><span style=color:#db784d>+ </span><span>(tmax[axis] </span><span style=color:#db784d>-</span><span> delta[axis]) </span><span style=color:#db784d>/</span><span> voxels_per_unit[axis]
</span></code></pre><blockquote><p>Except if <code>steps == 0</code> that means we hit a voxel on the edge of the grid, so we just return <code>entry_t</code> instead.</blockquote><p>And that's it, that's the entire algorithm implemented and <span class=highlight>ready to go</span>!<hr><h2 id=all-together-now>All Together Now!</h2><p>Now with everything put together, the final <code>find_nearest</code> function looks like this:<pre class=language-cpp data-lang=cpp style=color:#e8d4c0;background-color:#191919><code class=language-cpp data-lang=cpp><span style=color:#db784d>constexpr </span><span style=color:#95cc5e>int</span><span> MAX_STEPS </span><span style=color:#db784d>= </span><span style=color:#eaae2e>128</span><span>;
</span><span>
</span><span style=color:#95cc5e>float </span><span>VoxelTracer::</span><span style=color:#60a365>find_nearest</span><span>(</span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>ro</span><span>, </span><span style=color:#db784d>const</span><span> vec3</span><span style=color:#db784d>& </span><span style=color:#f8bb39;font-style:italic>rd</span><span>) </span><span style=color:#db784d>const </span><span>{ 
</span><span>    </span><span style=color:#7a7267>/* Find the ray entry point */ 
</span><span>    </span><span style=color:#db784d>const </span><span style=color:#95cc5e>float</span><span> entry_t </span><span style=color:#db784d>= </span><span style=color:#207241>ray_aabb</span><span>(grid_min, grid_max, ro, rd);
</span><span>
</span><span>    </span><span style=color:#db784d>if </span><span>(entry_t </span><span style=color:#db784d>== </span><span style=color:#eaae2e>1e30</span><span style=color:#95cc5e>f</span><span>) </span><span style=color:#db784d>return </span><span style=color:#eaae2e>1e30</span><span style=color:#95cc5e>f</span><span>; </span><span style=color:#7a7267>/* miss */
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Compute how many voxels occupy a unit in world space */
</span><span>    </span><span style=color:#db784d>const</span><span> vec3 voxels_per_unit </span><span style=color:#db784d>=</span><span> GRID_SIDE </span><span style=color:#db784d>/ </span><span>(grid_max </span><span style=color:#db784d>-</span><span> grid_min);
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Get the floating grid entry position */
</span><span>    </span><span style=color:#7a7267>/* `0.0001f` is to slightly nudge the point inside the grid */
</span><span>    </span><span style=color:#db784d>const</span><span> vec3 entry_pos </span><span style=color:#db784d>= </span><span>((ro </span><span style=color:#db784d>+</span><span> rd </span><span style=color:#db784d>* </span><span>(entry_t </span><span style=color:#db784d>+ </span><span style=color:#eaae2e>0.0001</span><span style=color:#95cc5e>f</span><span>)) </span><span style=color:#db784d>-</span><span> grid_min) </span><span style=color:#db784d>*</span><span> voxels_per_unit;
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Get our traversal constants */
</span><span>    </span><span style=color:#db784d>const</span><span> vec3 step </span><span style=color:#db784d>= </span><span style=color:#207241>sign_of_dir</span><span>(rd);
</span><span>    </span><span style=color:#db784d>const</span><span> vec3 delta </span><span style=color:#db784d>= </span><span style=color:#95cc5e>fabs</span><span>(</span><span style=color:#eaae2e>1.0</span><span style=color:#95cc5e>f </span><span style=color:#db784d>/</span><span> rd);
</span><span>
</span><span>    </span><span style=color:#7a7267>/* IMPORTANT: Safety clamp the entry point inside the grid */
</span><span>    vec3 pos </span><span style=color:#db784d>= </span><span style=color:#207241>clamp</span><span>(</span><span style=color:#95cc5e>floor</span><span>(entry_pos), </span><span style=color:#eaae2e>0</span><span>, GRID_SIDE);
</span><span>
</span><span>    </span><span style=color:#7a7267>/* Initialize the time along the ray when each axis crosses its next cell boundary */
</span><span>    vec3 tmax </span><span style=color:#db784d>= </span><span>(pos </span><span style=color:#db784d>-</span><span> entry_pos </span><span style=color:#db784d>+ </span><span style=color:#207241>max</span><span>(step, </span><span style=color:#eaae2e>0</span><span>)) </span><span style=color:#db784d>/</span><span> rd;
</span><span>
</span><span>    </span><span style=color:#7a7267>/* The traversal loop */
</span><span>    </span><span style=color:#95cc5e>int</span><span> axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>;
</span><span>    </span><span style=color:#db784d>for </span><span>(</span><span style=color:#95cc5e>int</span><span> steps </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>; steps </span><span style=color:#db784d><</span><span> MAX_STEPS; </span><span style=color:#db784d>++</span><span>steps) {
</span><span>        </span><span style=color:#7a7267>/* Fetch the cell at our current position */
</span><span>        </span><span style=color:#db784d>const </span><span style=color:#95cc5e>int</span><span> i </span><span style=color:#db784d>=</span><span> pos.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>*</span><span> GRID_SIDE </span><span style=color:#db784d>*</span><span> GRID_SIDE </span><span style=color:#db784d>+</span><span> pos.</span><span style=color:#f8bb39>y </span><span style=color:#db784d>*</span><span> GRID_SIDE </span><span style=color:#db784d>+</span><span> pos.</span><span style=color:#f8bb39>x</span><span>;
</span><span>        </span><span style=color:#db784d>const </span><span style=color:#95cc5e>unsigned int</span><span> voxel </span><span style=color:#db784d>=</span><span> grid[i];
</span><span>
</span><span>        </span><span style=color:#7a7267>/* Check if we hit a voxel which isn't 0 */
</span><span>        </span><span style=color:#db784d>if </span><span>(voxel) {
</span><span>            </span><span style=color:#db784d>if </span><span>(steps </span><span style=color:#db784d>== </span><span style=color:#eaae2e>0</span><span>) </span><span style=color:#db784d>return</span><span> entry_t;
</span><span>
</span><span>            </span><span style=color:#7a7267>/* Return the time of intersection! */
</span><span>            </span><span style=color:#db784d>return</span><span> entry_t </span><span style=color:#db784d>+ </span><span>(tmax[axis] </span><span style=color:#db784d>-</span><span> delta[axis]) </span><span style=color:#db784d>/</span><span> voxels_per_unit[axis];
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#7a7267>/* Step on the axis where `tmax` is the smallest */
</span><span>        </span><span style=color:#db784d>if </span><span>(tmax.</span><span style=color:#f8bb39>x </span><span style=color:#db784d><</span><span> tmax.</span><span style=color:#f8bb39>y</span><span>) {
</span><span>            </span><span style=color:#db784d>if </span><span>(tmax.</span><span style=color:#f8bb39>x </span><span style=color:#db784d><</span><span> tmax.</span><span style=color:#f8bb39>z</span><span>) {
</span><span>                pos.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>+=</span><span> step.</span><span style=color:#f8bb39>x</span><span>;
</span><span>                </span><span style=color:#db784d>if </span><span>(pos.</span><span style=color:#207241>x </span><span>< </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>||</span><span> pos.</span><span style=color:#f8bb39>x </span><span>></span><span style=color:#db784d>=</span><span> GRID_SIDE) </span><span style=color:#db784d>break</span><span>;
</span><span>                axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>0</span><span>;
</span><span>                tmax.</span><span style=color:#f8bb39>x </span><span style=color:#db784d>+=</span><span> delta.</span><span style=color:#f8bb39>x</span><span>;
</span><span>            } </span><span style=color:#db784d>else </span><span>{
</span><span>                pos.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>+=</span><span> step.</span><span style=color:#f8bb39>z</span><span>;
</span><span>                </span><span style=color:#db784d>if </span><span>(pos.</span><span style=color:#207241>z </span><span>< </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>||</span><span> pos.</span><span style=color:#f8bb39>z </span><span>></span><span style=color:#db784d>=</span><span> GRID_SIDE) </span><span style=color:#db784d>break</span><span>;
</span><span>                axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>2</span><span>;
</span><span>                tmax.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>+=</span><span> delta.</span><span style=color:#f8bb39>z</span><span>;
</span><span>            }
</span><span>        } </span><span style=color:#db784d>else </span><span>{
</span><span>            </span><span style=color:#db784d>if </span><span>(tmax.</span><span style=color:#f8bb39>y </span><span style=color:#db784d><</span><span> tmax.</span><span style=color:#f8bb39>z</span><span>) {
</span><span>                pos.</span><span style=color:#f8bb39>y </span><span style=color:#db784d>+=</span><span> step.</span><span style=color:#f8bb39>y</span><span>;
</span><span>                </span><span style=color:#db784d>if </span><span>(pos.</span><span style=color:#207241>y </span><span>< </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>||</span><span> pos.</span><span style=color:#f8bb39>y </span><span>></span><span style=color:#db784d>=</span><span> GRID_SIDE) </span><span style=color:#db784d>break</span><span>;
</span><span>                axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>1</span><span>;
</span><span>                tmax.</span><span style=color:#f8bb39>y </span><span style=color:#db784d>+=</span><span> delta.</span><span style=color:#f8bb39>y</span><span>;
</span><span>            } </span><span style=color:#db784d>else </span><span>{
</span><span>                pos.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>+=</span><span> step.</span><span style=color:#f8bb39>z</span><span>;
</span><span>                </span><span style=color:#db784d>if </span><span>(pos.</span><span style=color:#207241>z </span><span>< </span><span style=color:#eaae2e>0 </span><span style=color:#db784d>||</span><span> pos.</span><span style=color:#f8bb39>z </span><span>></span><span style=color:#db784d>=</span><span> GRID_SIDE) </span><span style=color:#db784d>break</span><span>;
</span><span>                axis </span><span style=color:#db784d>= </span><span style=color:#eaae2e>2</span><span>;
</span><span>                tmax.</span><span style=color:#f8bb39>z </span><span style=color:#db784d>+=</span><span> delta.</span><span style=color:#f8bb39>z</span><span>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#db784d>return </span><span style=color:#eaae2e>1e30</span><span style=color:#95cc5e>f</span><span>; </span><span style=color:#7a7267>/* miss */
</span><span>}
</span></code></pre><p>And when we once again shoot a ray for each pixel into the scene.<br> We get to finally see some <span class=highlight>voxels on screen</span>!<div class=img><img alt="Voxel ray tracing in action!" title="Voxel ray tracing in action!" src=https://mxcop.github.io/mxcop/img/articles/amanatides-and-woo/voxel-traversal.png width=520px><i>Voxel ray tracing in action!</i></div><hr><h2 id=wrapping-up>Wrapping Up</h2><p><span class=highlight>Thank you</span> for reading all the way to the end, I hope you now have a better understanding of the algorithm.<br> And I hope you enjoyed reading this article.<p>If you have anymore questions, or you found something incorrect in the article, let <a href=https://twitter.com/mxacop>me</a> know on Twitter (X).<br> <em>Also feel free to send me pictures of your voxel traversal working! :)</em></div><footer class=site-footer><p class=end-msg id=end-msg>---- Thanks for reading! ----</p><i>© 2020-<span id=year>2024</span> Max &LTmxcop>, All rights reserved</i></footer><script>const end_msg=document.getElementById(`end-msg`);const msg_idx=Math.floor(Math.random()*3);const msg_arr=[`Thank you for reading!`,`Hope you enjoyed the content!`,`Have a great day!`];end_msg.innerText=`---- `+ msg_arr[msg_idx]+ ` ----`;const year_el=document.getElementById(`year`);year_el.innerText=new Date().getFullYear()</script></main>